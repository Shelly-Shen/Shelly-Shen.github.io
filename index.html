<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shelly-Shen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="shelly&apos;s blog ———— share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="Shelly-Shen">
<meta property="og:url" content="http://Shelly-Shen.github.io/index.html">
<meta property="og:site_name" content="Shelly-Shen">
<meta property="og:description" content="shelly&apos;s blog ———— share everything">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shelly-Shen">
<meta name="twitter:description" content="shelly&apos;s blog ———— share everything">
  
    <link rel="alternate" href="/atom.xml" title="Shelly-Shen" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shelly-Shen</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Shelly-Shen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-scope" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/scope/" class="article-date">
  <time datetime="2018-10-16T08:56:27.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/scope/">scope</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>域：空间，范围，区域….  (除函数，if for 都不是作用域)<br>作用：读，写<br>浏览器：  “JS解析器”<br>域：   1）Script:全局变量，全局函数<br>自上而下<br>2）函数 ：由里到外</p>
<h3 id="1-“找一些东西”：var-function-参数"><a href="#1-“找一些东西”：var-function-参数" class="headerlink" title="1.“找一些东西”：var function 参数"></a>1.“找一些东西”：var function 参数</h3><pre><code>a=未定义   所有的变量在正式运行代码之前都提前赋了个值：未定义
fn1=function(){alert(1);}
</code></pre><p>所有的函数，在正式运行代码之前，都是整个函数块<br>JS的预解析      遇到重名的：只留一个<br>变量和函数重名只留函数  （全局域2.）</p>
<h3 id="2-逐行解析代码"><a href="#2-逐行解析代码" class="headerlink" title="2.逐行解析代码:"></a>2.逐行解析代码:</h3><h4 id="1-表达式-–-参数…-能够改变值得东西-，动作"><a href="#1-表达式-–-参数…-能够改变值得东西-，动作" class="headerlink" title="1)表达式: = + - * / % ++ – ! 参数….(能够改变值得东西 ，动作)"></a>1)表达式: = + - * / % ++ – ! 参数….(能够改变值得东西 ，动作)</h4><p>表达式可以修改预解析的值</p>
<h4 id="2-函数调用-：-1-预解析：var-function-参数-2-逐行解析"><a href="#2-函数调用-：-1-预解析：var-function-参数-2-逐行解析" class="headerlink" title="2)函数调用 ： [1]预解析：var function 参数  [2]逐行解析"></a>2)函数调用 ： [1]预解析：var function 参数  [2]逐行解析</h4><pre><code>全局域 
1.
alert(a);//未定义
var a = 1;
function fn1(){alert(2);}（函数声明）


2.
alert(a);//function a(){alert(4);}
var a=1;
alert(a);//1
function a(){alert(2);}
alert(a);//1
var a=3;
alert(a);//3
function a(){alert(4);
alert(a);//3

局部域(局部域改变得值和全局中的无关)
1.var a=1;
 function fn1(){
 alert(a);//undefined 
 var a=2;
 }
 fn1();
 alert(a);//1  

2.var a=1;
 function fn1(){
 alert(a);  // 1 （预解析是找不到 a=...  没有变量 没有参数便向全局域中寻找） 
 a=2;   //在局部域中找不到预解析中的a 所以向全局域中寻找 从而改变全局域中的值
 }
 fn1();
 alert(a);//2  

3.参数  
 var a=1;
 function fn1(a){  //预解析成 a = ... 
 alert(a);//undefined
 var a=2;  //a=2
 }
 fn1();
 alert(a);//1
4.var a=1;
 function fn1(a){    //由于fn1(a) 预解析成 a = 1 
 alert(a);//1
 var a=2;  
 }
 fn1(a);
 alert(a);//1  （此时局部a和全局a并无关系）  
</code></pre><h3 id="小tip："><a href="#小tip：" class="headerlink" title="小tip："></a>小tip：</h3><p>想要哎获取函数内的值</p>
<h4 id="1-通过全局变量"><a href="#1-通过全局变量" class="headerlink" title="1.通过全局变量"></a>1.通过全局变量</h4><pre><code>var str = &apos;&apos;;
function fn1(){
var a=&apos;123&apos;;
str = a;
}    
fn1();
alert(str); 
</code></pre><h4 id="2-通过局部函数调用"><a href="#2-通过局部函数调用" class="headerlink" title="2.通过局部函数调用"></a>2.通过局部函数调用</h4><pre><code>function fn2(){
var a=&apos;123&apos;;
fn3(a);
}
fn2();
function fn3(a){
alert(a);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/scope/" data-id="cjnbhxifm0004zghojtn9bkwt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-draw" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/draw/" class="article-date">
  <time datetime="2018-10-16T08:55:44.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/draw/">Canvas和SVG的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h1><p>1.Canvas基于位图（像素）的：<br>放大后会出现像素格但颜色选择比较多，可以渲染比较真实感的图<br>2.canvas不可用事件处理器<br>3.一旦被绘制完成不会继续得到浏览器的关注<br>4.修改以后（如位置改变）会影响到整个场景，需要重新渲染<br>5.适合动态渲染，大数据量绘制如游戏场景渲染<br>6.能以JPG/PNG的形式存储<br>7.依赖于HTML，通过脚本绘制</p>
<h1 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h1><p>1.基于矢量：不依赖分辨率<br>2.依赖于DOM,绘制的图形被视为对象,适用于交互,因此可以用JS控制元素，使用事件处理器<br>3.对象属性一旦发生变化，浏览器能自动重现图形<br>4.复杂度高，会减慢渲染速度<br>5.适用于大型渲染区域的程序如地图开发，静态高保真图形等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/draw/" data-id="cjnbhxifl0003zgho3367babo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-datastore" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/datastore/" class="article-date">
  <time datetime="2018-10-16T08:44:37.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/datastore/">浏览器存储技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h4 id="1-客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie"><a href="#1-客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie" class="headerlink" title="1.客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie"></a>1.客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie</h4><h4 id="2-document-cookie-name-value-expires-过期时间-path-页面路径-domain-域-secure-SSL链接时才能使用cookie的安全标志"><a href="#2-document-cookie-name-value-expires-过期时间-path-页面路径-domain-域-secure-SSL链接时才能使用cookie的安全标志" class="headerlink" title="2.document.cookie=name=value;expires=过期时间;path:页面路径;domain=域;secure(SSL链接时才能使用cookie的安全标志)"></a>2.document.cookie=name=value;expires=过期时间;path:页面路径;domain=域;secure(SSL链接时才能使用cookie的安全标志)</h4><h4 id="3-子cookie"><a href="#3-子cookie" class="headerlink" title="3.子cookie"></a>3.子cookie</h4><pre><code>document.cookie=data=name=Jake&amp;book=Professor;  
</code></pre><h4 id="4-有4k的存储空间-每条cookie有长度限制"><a href="#4-有4k的存储空间-每条cookie有长度限制" class="headerlink" title="4.有4k的存储空间,每条cookie有长度限制"></a>4.有4k的存储空间,每条cookie有长度限制</h4><h4 id="5-Js处理cookie"><a href="#5-Js处理cookie" class="headerlink" title="5.Js处理cookie"></a>5.Js处理cookie</h4><pre><code>下列为拥有子cookie的处理方法

var SubCookieUtil = {
get:function(name,subname){
    var subCookies = this.getAll(name);
    if(subCookies){
        return subCookies[subname];
    }else{
        return null;
    }
},
getAll:function(name){
    var cookieName = encodeURIComponent(name)+&quot;=&quot;;
    var cookieStart = document.cookie.indexOf(cookieName);
    var cookieEnd,
    subCookies,
    cookieValue = null,
    i,parts,result = {};
    if(cookieStart&gt;-1){
        cookieEnd = document.cookie.indexOf(&quot;;&quot;,cookieStart);
        if(cookieEnd == -1){
            cookieEnd = document.cookie.length;
        }

        cookieValue = document.cookie.substring(cookieStart+cookieName.length,cookieEnd);
        if(cookieValue.length &gt; 0){
            subCookies = cookieValue.split(&quot;&amp;&quot;);
            for(i = 0;i&lt;subCookies.length;i++){
                parts = subCookies[i].split(&quot;=&quot;);
                result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
            }
            return result;
        }
    }
    return null;
},
set:function(name,subName,value,expires,path,domin,secure){
    var subCookies = this.getAll
    (name)||{};
    subCookies[subName] = value;
    this.setAll(name,subCookies,expires,path,domin,secure);
},
setAll:function(name,subCookies,expires,path,domin,secure){
    var cookieText = encodeURIComponent(name)+&quot;=&quot;,
    subCookiesParts = new Array(),
    subName;
    for(subName in subCookies){
        if(subName.length&gt;0&amp;&amp;subCookies.hasOwnProperty(subName)){
            subCookiesParts.push(encodeURIComponent(subName)+&quot;=&quot;+encodeURIComponent(subCookies[subName]));
        }
    }
    if(subCookiesParts.length &gt; 0){
        cookieText +=subCookiesParts.join(&quot;&amp;&quot;);
        if(expires instanceof Date){
            cookieText += &quot;;expires=&quot;+expires.toGMTString();
        }
        if(path){
            cookieText += &quot;;path=&quot;+path;
        }
        if(domin){
            cookieText+=&quot;;domain=&quot;+domin;
        }
        if(secure){
            cookieText+=&quot;;secure&quot;;
        }
    }else{
            cookieText += &quot;;expires&quot;+(new Date(0)).toGMTString();
        }
        document.cookie = cookieText;
},
unset:function(name,subname,path,domain,secure){
    var subcookies = this.getAll(name);
    if(subcookies){
        delete subCookies[subname];
        this.setAll(name,subCookies,null,path,somain,secure);
    }
},
unsetAll:function(name,path,domain,secure){
    this.setAll(name,null,new Date(0),path,domain,secure);
}
};
SubCookieUtil.set(&quot;data&quot;,&quot;name&quot;,&quot;Nicole&quot;);
var getData = SubCookieUtil.getAll(&quot;data&quot;);
alert(SubCookieUtil.get(&quot;data&quot;,&quot;name&quot;));
</code></pre><h2 id="userData"><a href="#userData" class="headerlink" title="userData"></a>userData</h2><h4 id="iE处理用户数据的方式"><a href="#iE处理用户数据的方式" class="headerlink" title="iE处理用户数据的方式"></a>iE处理用户数据的方式</h4><pre><code>&lt;div style=&quot;behavior:url(#default#userData)&quot; id=&quot;dataStore&quot;&gt;&lt;/div&gt;
//js
var dataStore = document.getElementById(dataStore);
dataStore.setAttribute(&quot;name&quot;,&quot;Jake&quot;);
dataStore.setAttribute(&quot;book&quot;,&quot;professor&quot;);
//保存数据
dataStore.save(&quot;BookInfo&quot;)；
//设置数据空间
dataStore.load(&quot;BookInfo&quot;); 
//获取数据空间  
dataStore.getAttribute(&quot;name&quot;); 
//获取数据  
dataStore.removeAttribute(&quot;book&quot;);  
dataStore.save(&quot;BookInfo&quot;);
//删除后需再次提交更改  
</code></pre><h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><h4 id="storage类型"><a href="#storage类型" class="headerlink" title="storage类型"></a>storage类型</h4><p>1.被控制在客户端上，不会将数据返回给服务器<br>2.内存为5M或2.5M，可以大量存储数据</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>clear()删除全部<br>setItem(name,value)<br>getItem(name)<br>removeItem(name)<br>key(Index)获得在Index索引处的属性  </p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>length</p>
<h5 id="storage事件"><a href="#storage事件" class="headerlink" title="storage事件"></a>storage事件</h5><p>domain发生变化的存储空间的域<br>key发生变化的key<br>oldValue<br>newValue</p>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>会话存储，当浏览器关闭则自动清除不再保存</p>
<pre><code>sessionStorage.setItem(&quot;name&quot;,&quot;Nicoke&quot;);
sessionStorage.book = &quot;Professor&quot; //使用属性存储数据  var name = sessionStorage.getItem(&quot;name&quot;); 
var book = sessionStorage.book;
delete sessionStorage.name;  //在webkit中无效  
sessionStorage.remove(&quot;book&quot;);      
EventUtil.addHandler(document,&quot;storage&quot;,function(event){
    alert(event.domain);
});
</code></pre><h4 id="golbalStorage"><a href="#golbalStorage" class="headerlink" title="golbalStorage"></a>golbalStorage</h4><p>如果没有delete或remove或用户手动清除缓存，globalStorage将长期保存，一直保留在磁盘上</p>
<pre><code>golbalStorage[&quot;www.text.com&quot;].name = &quot;Nicole&quot;;
//[&quot;www.text.com&quot;]针对域名www.text.com的存储空间  
globalStorage[&quot;www.text.com&quot;].removeItem(&quot;name&quot;);
globalStorage[local.host].setItem();
//若不确定域名则使用local.host
</code></pre><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p> 取代globalStorage对象，不同的是localStorage不用实现定义域名，直接globalStorage[local.host] </p>
<pre><code>localStorage.setItem(&quot;name&quot;,&quot;Nickle&quot;);    
</code></pre><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>可以理解为用对象保存数据的数据库（MySql是表结构）  </p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><pre><code>var indexedDB = window.indexedDB||window.msIndexedDB||window.mozIndexedDB||window.webkitIndexedDB; 
//兼容性
var request,database;
var request = indexedDB.open(&quot;admin&quot;);
//admin为数据库名，如果不存在则会自动创建 ，返回请求对象，对象上可以添加两个事件error和success
request.onerror = function(event){
    alert(event.target.errorCode);
};
request.onsuccess = function(event){
    database = event.target.result;
    //返回数据内容
    if(database.version != &quot;1.0&quot; )
        request = database.setVersion(&quot;1.0&quot;);
        //设置版本号,返回请求对象
        request.onblock = function(){
            alert(&quot;请关闭其他页面再次尝试&quot;);
        }
        //并发问题：在想要更新数据库版本但另一个页面已打开数据库时
        request.onerror = function(event){
            alert(event.target.errorCode);
        };
        request.onsuccess = function(event){
            alert(database.name+database.version);
        }
    }else{
        alert(&quot;已经配置好版本号了&quot;)
    }
}
</code></pre><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>浏览器开了两个页面打开同一链接，当一个页面试图更新另一个还没有加载完的数据库时，调用setVersion()</p>
<pre><code>database.onversionChange = function(){
    database.close();
};
</code></pre><h4 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h4><pre><code>var user = {
    username:&quot;007&quot;,
    firstName : &quot;Jone&quot;,
    lastName:&quot;Bond&quot;,
    password:&quot;foo&quot;
};
var store = database.createObjectStore(&quot;users&quot;,{keyPath:&quot;userName&quot;});
//设置名为user的存储空间（在SQL即设名user的表）并设置主键username
//向存储空间添加数据
var i= 0 ,
requests = [];
len = user.length;
for(i&lt;len){
    request =  store.add[user[i++]];
    //add()添加新增数据和put方法添加更新数据，同样拥有两个事件处理程序  
    request.onerror = function(event){...}
    request.onsuccess = function(event){...}
    requests.push(request);
}
</code></pre><h4 id="创建事物-会返回事务级事件处理程序onerror和oncomplete"><a href="#创建事物-会返回事务级事件处理程序onerror和oncomplete" class="headerlink" title="创建事物(会返回事务级事件处理程序onerror和oncomplete)"></a>创建事物(会返回事务级事件处理程序onerror和oncomplete)</h4><pre><code>var transaction = database.transaction(&quot;users&quot;,IDBTransaction.READ_WRITE);
/*第一个参数为存储空间名,可指定多个存储空间，放在数组中，加载存储空间中的数据，通过事务访问  
第二个参数为访问模式：READ_ONLY  READ_WRITE VERSION_CHANGE
事件方法(会返回    新请求对象)：
objectStore()只加载特定的存储空间 
get()delete()接收对象键
add() put() clear()*/
var request = transaction.objectStore(&quot;users&quot;).get(&quot;007&quot;);
request.onerror ....  
transaction.oncomplete = function(event){...}
</code></pre><h4 id="游标查询"><a href="#游标查询" class="headerlink" title="游标查询"></a>游标查询</h4><pre><code>var store = transaction.objectStore(&quot;users&quot;);
var IDBKeyRange = window.IDBKeyRange||window.webkitKeyRange;
//键范围实例
var IDBCursor = window.IDBCursor||window.webkitIDBCursor;
//游标方向:
var nextNoDuplicate = IDBKeyRange.NEXT_NO_DUPLICATE;
//游标方向为从第一项到最后一项并跳过重复
//NEXT PREV PREV_NO_DUPLICATE
var range = IDBKeyRange.Bound(&quot;007&quot;,&quot;ace&quot;,true,false);
//此实例的方法：only(&quot;007&quot;)||upperBound()上界，游标从头开始到参数位置||lowerBound()下界，游标从参数位置到最后一个对象||Bound()
//布尔值值是否包含参数,false则跳过
request = store.openCursor(range,nextNoDuplicate);
//接收两个参数，IDBKeyRange的实例和IDBCursor的实例
//事务创建好后创建游标
request.onerror..
request.onsuccess = function(event){
    var cursor = event.target.result,
    value,updateRequest;
    /*此实例有几个属性：
        direction:IDBCursor.NEXT(0)(默认值下一个) ||IDBCursor.NEXT_NO_DUPLICATE(1)(下一个不重复的项）||IDBCursor.PREV_NO_DUPLICATE(2)（前一项）||IDBCursor.PREV_NO_DUPLICATE(前一个不重复的项)
        1.key  2.value  3.primaryKey:游标使用的键
    此实例有几个方法
        update()delete()continue()advance()
    */
    if(cursor){
        if(cursor.key == &quot;foo&quot;){
            value = cursor.value;
            value.password = &quot;magic&quot;;
            var updateRequest = cursor.update(value);//update也会创建一个新请求
            //delete同上一条，没有参数，删除当前项
        }
        console.log(cursor.key+&quot;:&quot;+JSON.stringify(event.value));
        cursor.continue();
    }
}
</code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>var index = store.createIndex(&quot;username&quot;,&quot;username&quot;,{unique:false});
//第一个参数：索引名 第二个参数：索引属性名 第三个参数：键是否唯一    
//store.Index(&quot;username&quot;)方法取得索引
var indexName = store.indexNames
//对象存储空间的对象indexName属性可访问到空间中的所有索引
var i = 0,len = indexNames.length;
while(i&lt;len){
    index = store.index(indexName[i++]);
    console.log(index.name+&quot;=&quot;+index.ketPath+index.unique);    
}
/*index方法：
    get()从索引中取对象 参数索引键 
    getKey()根据给定索引键取得主键
    deleteIndex(&quot;username&quot;) 
    openCursor() openKeyCursor()能在索引中打开游标并可以创建特殊的能返回每个记录主键的游标
属性：name索引名 keyPath创建索引的属性路径 onjectStore索引对象存储空间unique索引键是否唯一的布尔值*/
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/datastore/" data-id="cjnbhxifj0002zgho9og5mhg9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/css3/" class="article-date">
  <time datetime="2018-10-16T08:39:13.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/css3/">css3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><pre><code>box-shadow:0 1px 4px rgba(0, 0, 0, 0.3), 0 0 40px rgba(0, 0, 0, 0.1) inset;
</code></pre><p>前两个数值时偏移量，后一个是模糊半径；<br>第一个是外阴影，第二个是内嵌阴影，注意看inset这个属性</p>
<p>###线性渐变liner-gradient</p>
<pre><code>background:liner-gradient(to bottom,#fff,#999)
                          渐变方向等价与180deg            颜色的起始点和终点
</code></pre><h3 id="径向渐变radial-gradient"><a href="#径向渐变radial-gradient" class="headerlink" title="径向渐变radial-gradient"></a>径向渐变radial-gradient</h3><p><a href="http://www.css88.com/book/css/values/image/radial-gradient(" target="_blank" rel="noopener">http://www.css88.com/book/css/values/image/radial-gradient().htm</a>.htm)</p>
<h3 id="border-image-url-切割图片的像素-方式（round圆满的铺满-stretch拉伸-repeat重复）"><a href="#border-image-url-切割图片的像素-方式（round圆满的铺满-stretch拉伸-repeat重复）" class="headerlink" title="border-image:url 切割图片的像素 方式（round圆满的铺满|stretch拉伸|repeat重复）;"></a>border-image:url 切割图片的像素 方式（round圆满的铺满|stretch拉伸|repeat重复）;</h3><pre><code>border-image:url(border.png) 70 70 70 70 round;
</code></pre><p><img src="/images/border-image2.png" alt=""><br><img src="/images/border-image1.png" alt=""><br><img src="/images/border-image3.png" alt=""></p>
<h4 id="text-overflow"><a href="#text-overflow" class="headerlink" title=".text-overflow:"></a>.text-overflow:</h4><p>设置是否使用省略标记<br>text-overflow:clip(剪切)|ellipsis(显示省略标记)  </p>
<h4 id="white-space-nowrap"><a href="#white-space-nowrap" class="headerlink" title="white-space:nowrap"></a>white-space:nowrap</h4><p>强制文本在一行显示  </p>
<h4 id="overflow-hidden"><a href="#overflow-hidden" class="headerlink" title="overflow:hidden"></a>overflow:hidden</h4><p>溢出内容为隐藏</p>
<h4 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap:"></a>word-wrap:</h4><p>文本超过容器边界时是否转行<br>normal(控制连续文本换行)|break-word(内容将在边界内换行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text-overflow:epllipsis;</span><br><span class="line">overflow:hidden;</span><br><span class="line">white-space:nowrap;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/text-overflow.png" alt=""><br><img src="/images/text-overflow2.png" alt=""></p>
<h4 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h4><p>自定义字体<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@font-face&#123;</span><br><span class="line">font-family:字体名称；</span><br><span class="line">src:字体文件路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-shadow:x-Offset Y-Offset blur color;</span><br></pre></td></tr></table></figure>
<p>blur:阴影的模糊程度，不能为负<br>text-shadow: 2px 2px 20px red,-2px -2px 20px white;加逗号可以设置多个阴影</p>
<h4 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h4><p>背景图片的起始点<br>border-box:从边框<br>padding-box:从内边距<br>content-box:从内容区域即其子元素<br><img src="/images/background-origin.jpg" alt=""></p>
<p>####background-clip<br>裁剪背景位置<br>属性:<br>border-box<br>padding-box<br>content-box</p>
<p><img src="/images/background-clip.jpg" alt=""></p>
<h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><p>值：<br>auto：使用默认值<br>长度值：200px 50px<br>百分比<br>cover:覆盖，等比缩放填满整个容器<br>contain:容纳，等比缩放至贴紧容器边缘</p>
<p><img src="/images/multiple-backgrounds.png" alt=""></p>
<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p><img src="/images/E[attr].png" alt=""></p>
<h3 id="root根选择器"><a href="#root根选择器" class="headerlink" title="root根选择器"></a>root根选择器</h3><h3 id="not否定选择器"><a href="#not否定选择器" class="headerlink" title="not否定选择器"></a>not否定选择器</h3><pre><code>    div:not([id=footer]){
    background:orange;
}
</code></pre><h3 id="empty"><a href="#empty" class="headerlink" title=":empty"></a>:empty</h3><p>选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。</p>
<h3 id="target"><a href="#target" class="headerlink" title=":target"></a>:target</h3><p>选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。我们先来上个例子，然后再做分析。</p>
<pre><code>#brand:target p {
     background: orange;
     color: #fff;
}
&lt;/style&gt;
&lt;/head&gt; 
&lt;body&gt;
    &lt;div class=&quot;menuSection&quot; id=&quot;brand&quot;&gt;
        &lt;h2&gt;&lt;a href=&quot;#brand&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;
        &lt;p&gt;content for Brand&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)</p>
<h3 id="：first-child"><a href="#：first-child" class="headerlink" title="：first-child"></a>：first-child</h3><h3 id="last-child"><a href="#last-child" class="headerlink" title=":last-child"></a>:last-child</h3><h3 id="nth-child-n"><a href="#nth-child-n" class="headerlink" title="nth-child(n)"></a>nth-child(n)</h3><h3 id="nth-last-child"><a href="#nth-last-child" class="headerlink" title="nth-last-child()"></a>nth-last-child()</h3><h3 id="first-of-type"><a href="#first-of-type" class="headerlink" title="first-of-type"></a>first-of-type</h3><h3 id="last-of-type"><a href="#last-of-type" class="headerlink" title="last-of-type"></a>last-of-type</h3><h3 id="nth-of-type"><a href="#nth-of-type" class="headerlink" title="nth-of-type()"></a>nth-of-type()</h3><h3 id="nth-last-of-type"><a href="#nth-last-of-type" class="headerlink" title="nth-last-of-type()"></a>nth-last-of-type()</h3><h3 id="only-child"><a href="#only-child" class="headerlink" title="only-child"></a>only-child</h3><h3 id="only-of-type"><a href="#only-of-type" class="headerlink" title="only-of-type"></a>only-of-type</h3><h3 id="enabled"><a href="#enabled" class="headerlink" title=":enabled"></a>:enabled</h3><h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3><h3 id="selected-鼠标选择"><a href="#selected-鼠标选择" class="headerlink" title="selected(鼠标选择)"></a>selected(鼠标选择)</h3><h3 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h3><h3 id="read-only"><a href="#read-only" class="headerlink" title="read-only"></a>read-only</h3><h3 id="read-write"><a href="#read-write" class="headerlink" title="read-write"></a>read-write</h3><h3 id="after-before"><a href="#after-before" class="headerlink" title="::after ::before"></a>::after ::before</h3><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><h3 id="rotate旋转"><a href="#rotate旋转" class="headerlink" title="rotate旋转"></a>rotate旋转</h3><pre><code>transform:rotate(20deg);
</code></pre><p>正值为顺时针</p>
<h3 id="skew扭曲"><a href="#skew扭曲" class="headerlink" title="skew扭曲"></a>skew扭曲</h3><pre><code>transform:skem(20deg,5deg);
</code></pre><p><img src="/images/skew.png" alt=""></p>
<h3 id="scale缩放"><a href="#scale缩放" class="headerlink" title="scale缩放"></a>scale缩放</h3><pre><code>transform:scale(1.8,1.8);
</code></pre><p>前值为X轴方向，后值为y轴方向（即宽高）<br><strong>注意</strong>： scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大</p>
<h3 id="translate位移"><a href="#translate位移" class="headerlink" title="translate位移"></a>translate位移</h3><pre><code>transform:translate(100px,100px);
transform；translate(50%,50%);
</code></pre><h3 id="matrix矩阵"><a href="#matrix矩阵" class="headerlink" title="matrix矩阵"></a>matrix矩阵</h3><p><a href="http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/" title="matrix" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/</a><br><strong>Matrix()与translate()关系：translate(x,y)对应Matrix(1,0,0,1,x,y);<br>Matrix()与scale()关系：scale(x,y)对应Matrix(x,0,0,y,0,0);<br>Matrix()与rotate()关系：rotate(x)对应Matrix(cos(x),sin(x),-sin(x),cos(x),0,0)<br>Matrix()与skew()关系：skew(x,y)对应Matrix(1,tan(x),tan(y),1,0,0)</strong> </p>
<p>###transform-origin<br>用来设置元素的运动基点，transfrom-origin：50% 50%表示元素运动基点在整个中心是个默认值。px代表元素运动离元素运动基点的距离</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><img src="/images/transition.png" alt=""></p>
<p>###transition-property过渡属性</p>
<pre><code>指定过渡的css属性
</code></pre><p><img src="/images/transition-property.png" alt="">  </p>
<p><img src="/images/transition-property2.png" alt=""><br>假设你的初始状态设置了样式“width”,“height”,“background”,当你在终始状态都改变了这三个属性，那么all代表的就是“width”、“height”和“background”。</p>
<p>###transition-duration动画时间<br>从一个属性过渡到另一个属性需要的时间</p>
<pre><code>transition-duration:0.2s;
</code></pre><h3 id="transition-delay过渡延迟时间"><a href="#transition-delay过渡延迟时间" class="headerlink" title="transition-delay过渡延迟时间"></a>transition-delay过渡延迟时间</h3><p>触发动作，过渡开始前的时间</p>
<pre><code>transition-delay:.2s;
</code></pre><h3 id="transition-timing-function过渡函数"><a href="#transition-timing-function过渡函数" class="headerlink" title="transition-timing-function过渡函数"></a>transition-timing-function过渡函数</h3><p><strong> 值：</strong><br>ease:速度由快至慢<br>linear:匀速<br>ease-in:渐显(加速) （比ease效果更明显）<br>ease-out:渐隐（减速）<br>ease-in-out:渐显渐隐（先加速再减速）  </p>
<p>###keyframes关键帧</p>
<pre><code>@keyframes changecolor{
    0%{
        background:yellow;
    }
    40%{
        background:red;
    }
    60%{
        background:blue;
    }
}
div:hover{
    animation:changecolor 5s ease-in .2s;
}    
</code></pre><p>###animation-name<br><strong> 值：</strong><br>none：无动画效果，可用覆盖任何动画<br>indent:@keyframes创建的动画名</p>
<p>###animation-duration动画时间</p>
<p>###animation-timing-function动画播放方式</p>
<p>###animation-delay多长时间以后开始播放动画</p>
<p>###animation-iteration-count 动画重复次数<br><strong> 值：</strong><br>infinite无限或数字<br>    animation-iteration-count:5;    </p>
<p>###animation-direction<br><strong> 值：</strong><br>normal:每次循环都是向前播放<br>alternate:偶数次向前播放，奇数次反向（反复）    </p>
<p>###animation-play-state<br><strong> 值：</strong><br>paused暂停<br>running播放（从暂停的地方开始播放）</p>
<pre><code>demo:当鼠标放到元素上时元素才会移动    
div{
    animation:move;
    animation-duration:10s;
    animation-timing-function:ease-in;
    animation-delay:2s;
    animation-direction:alterate;
    animation-play-state:paused;    
}
div:hover{
    animation-play-state:running;    
}
</code></pre><p>###animation-fill-mode<br><strong> 值：</strong><br>none：动画结束后回到初始帧状态<br>forwards:动画结束后停止在最后一帧状态<br>backwards:在animate-delay指定的时间之前应用初始帧<br>both:forwards+backwards</p>
<h2 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h2><p><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/</a></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="columns多列布局"><a href="#columns多列布局" class="headerlink" title="columns多列布局"></a>columns多列布局</h3><p><strong> 值：</strong><br>width+列数‘</p>
<pre><code>columns:150px 3;
</code></pre><h5 id="column-width"><a href="#column-width" class="headerlink" title="column-width:"></a>column-width:</h5><h5 id="column-count"><a href="#column-count" class="headerlink" title="column-count:"></a>column-count:</h5><h5 id="column-gap列间距："><a href="#column-gap列间距：" class="headerlink" title="column-gap列间距："></a>column-gap列间距：</h5><h5 id="column-rule列边框"><a href="#column-rule列边框" class="headerlink" title="column-rule列边框"></a>column-rule列边框</h5><h5 id="column-span跨所有列：all-none-不跨列"><a href="#column-span跨所有列：all-none-不跨列" class="headerlink" title="column-span跨所有列：all|none(不跨列)"></a>column-span跨所有列：all|none(不跨列)</h5><pre><code>column-count: 3;
column-gap: 2em;
column-rule:1px solid red;
</code></pre><p><img src="/images/colums.png" alt=""></p>
<h3 id="盒模型box-sizing"><a href="#盒模型box-sizing" class="headerlink" title="盒模型box-sizing"></a>盒模型box-sizing</h3><p><img src="/images/border-box.jpg" alt=""><br>在自适应布局中通常会因为padding将布局打乱，border-box可解决</p>
<pre><code>.dov1{
    width:60%;
}
.div2{
    width:40%;
    padding:40px;    
    box-sizing:borde-box;
}
</code></pre><h3 id="伸缩布局"><a href="#伸缩布局" class="headerlink" title="伸缩布局"></a>伸缩布局</h3><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool
</a></p>
<p>display:flex;<br>主轴方向flex-direction:row|row-reverse|column|column-reverse<br>决定侧轴flex-wrap:nowrap|wrap|wrap-reverse<br>以上简写：flex-flow:<flex-direction>值 flex-wrap值； </flex-direction></p>
<p>主轴对其方式：justify-content:flex-start|flex-end|center|space-between|space-around<br>侧轴对其方式:align-items:flex-start|flex-end|center|stretch|baseline<br>多行侧轴对其方式：align-content:flex-start|flex-end|center|space-between|space-around </p>
<p>排列顺序：order:数字（数值越小排列越靠前）<br>若想设置两个元素一个排第一，一个排最后则需将前者设为-1；后者设为0即可</p>
<p>放大flex-grow：数字（按元素比例，默认为0）<br>缩小flex-shrink:数字（按元素比例2倍3倍等，默认为1）<br>伸缩基准值：flex-basis:auto(默认)|<length px=""><br>以上三种属性的缩写flex:none(0 0 auto)|[flex-grow(必须) flex-shrink(可选) flex-basis(可选)] （默认为0 1 auto）<br>flex-self覆盖align-items</length></p>
<h2 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h2><p>常用：srceen(电脑屏幕) all(全部) print(打印或打印预览模式   </p>
<h3 id="媒体类型引用"><a href="#媒体类型引用" class="headerlink" title="媒体类型引用"></a>媒体类型引用</h3><h4 id="1-media方法"><a href="#1-media方法" class="headerlink" title="1.media方法"></a>1.media方法</h4><p>（1）link中调用</p>
<pre><code>&lt;link style=&quot;text/css&quot; url=&quot;&quot; rel=&quot;stylesheet&quot; media=&quot;srceen&quot; &gt;&lt;/link&gt;
//默认为all
</code></pre><p>（2）样式文件中引用媒体类型</p>
<pre><code>@media srceen{
    选择器{样式代码}
}
</code></pre><p>（3）在head中调用</p>
<pre><code>&lt;head&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        @media{
            选择器{样式代码}
        }
    &lt;/style&gt;
&lt;/head&gt;
</code></pre><h4 id="1-import"><a href="#1-import" class="headerlink" title="1.@import"></a>1.@import</h4><p>用法同media，除media的第一个方法外<br>（1）</p>
<pre><code>@importurl(reset.css) print;
</code></pre><p>（2）ie6,ie7不兼容</p>
<pre><code>&lt;head&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        @importurl(reset.css) all;
    &lt;/style&gt;
&lt;/head&gt;
</code></pre><h3 id="media-queries使用方法"><a href="#media-queries使用方法" class="headerlink" title="media queries使用方法"></a>media queries使用方法</h3><h4 id="最大最小宽度max-width-min-width"><a href="#最大最小宽度max-width-min-width" class="headerlink" title="最大最小宽度max-width/min-width"></a>最大最小宽度max-width/min-width</h4><p>定义适用于何种屏幕大小的设备中</p>
<pre><code>@media srceen and (max-width:800px){
    .ads{
        display:none;
    }    
}
//当屏幕等于或小于800px时，广告窗口消失
@media srceen and (min-width:800px){
    .wrapper{
        width:900px;
    }
}
//当屏幕大于800px时，.wrapper容器宽度变为900px
</code></pre><p>综合</p>
<pre><code>@media srceen and (min-width:300px) and (max-width:800px);
</code></pre><h4 id="限制设备宽度"><a href="#限制设备宽度" class="headerlink" title="限制设备宽度"></a>限制设备宽度</h4><pre><code>&lt;link rel=&quot;sheetstyle&quot; media=&quot;srceen and (max-device-width:450px)&quot; href=&quot;iphone.css&quot;&gt;
//iphone.css”样式适用于最大设备宽度为480px，比如说iPhone上的显示
</code></pre><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><pre><code>@media not print and (max-width:1200px){样式}
//样式代码将被使用在除打印设备和设备宽度小于1200px下所有设备中
</code></pre><h4 id="only"><a href="#only" class="headerlink" title="only"></a>only</h4><pre><code>@&lt;link rel=&quot;sheetstyle&quot; media=&quot;only srceen and(max-device-width:450px)&quot; href=&quot;android240.css&quot;&gt;
</code></pre><h4 id="多条语句"><a href="#多条语句" class="headerlink" title="多条语句"></a>多条语句</h4><pre><code>&lt;link rel=&quot;sheetstyle&quot; media=&quot;srceen and(max-width:800px), handheld and(max-width:480px)&quot; href=&quot;&quot;&gt;
</code></pre><h3 id="响应式responsive设计"><a href="#响应式responsive设计" class="headerlink" title="响应式responsive设计"></a>响应式responsive设计</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>1.流体网格<br>2.弹性图片</p>
<pre><code>img{max-width:100%};

来看一个断点解决图片自适应的例子。
&lt;img src=&quot;image.jpg&quot; data-src-600px=&quot;image-600px.jpg&quot; data-src-800px=&quot;image-800px.jpg&quot; alt=&quot;&quot; /&gt;
</code></pre><p>3.媒体查询<br>根据设备的尺寸，查询出适配的样式</p>
<p><strong> 注意：</strong><br>在Responsive布局中，可以毫无保留的丢弃：<br>第一， 尽量少用无关紧要的div；<br>第二，不要使用内联元素（inline）；<br>第三，尽量少用JS或flash；<br>第四，丢弃没用的绝对定位和浮动样式；<br>第五，摒弃任何冗余结构和需要使用100%设置</p>
<h4 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h4><p><meta name="" content=""><br><img src="/images/content.jpg" alt=""></p>
<pre><code>&lt;meta name=”viewport” content=”width=device-width,minimun-scale=1.0” /&gt;
//适应设备宽度，不可缩放
</code></pre><p>为适应IE老版本的脚本</p>
<pre><code>media-queries.js(http://code.google.com/p/css3-mediaqueries-js/)      

 respond.js(https://github.com/scottjehl/Respond)

 &lt;!—[if lt IE9]&gt;
  &lt;scriptsrc=http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js&gt;&lt;/script&gt;
 ​&lt;![endif]&gt;
</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>1.1024px显屏</p>
<pre><code>@media srceen and(max-device－width:1024px){样式}
</code></pre><p>2.800px显屏<br>3.640px显屏<br>4.ipad横版</p>
<pre><code>@media srceen and (max-device－width:1024px) and(orientation定向:landscape横){样式}
</code></pre><p>5.ipad竖屏</p>
<pre><code>@media screen and (max-device-width: 768px) and (orientation: portrait)
</code></pre><p>6.iPhone 和 Smartphones</p>
<pre><code>@media screen and (min-device-width: 320px) and (min-device-width: 480px) 
</code></pre><p><img src="/images/media实例.png" alt=""></p>
<h2 id="用户界面及其他重要属性"><a href="#用户界面及其他重要属性" class="headerlink" title="用户界面及其他重要属性"></a>用户界面及其他重要属性</h2><h3 id="resize用户自行拖拽宽高"><a href="#resize用户自行拖拽宽高" class="headerlink" title="resize用户自行拖拽宽高"></a>resize用户自行拖拽宽高</h3><p><strong> 值：</strong><br>none:不允许拖拽<br>both:宽高都可<br>horizontal水平：仅修改宽度<br>vertical竖直：仅修改高<br>inherit:继承父元素resize属性值</p>
<h3 id="outline外边框"><a href="#outline外边框" class="headerlink" title="outline外边框"></a>outline外边框</h3><pre><code>outline:red solid 2px;
outline-offset:5px  //偏移量 正值为向外偏移，负值为向内偏移 需单独写
outline：inherit
</code></pre><h3 id="content生成内容"><a href="#content生成内容" class="headerlink" title="content生成内容"></a>content生成内容</h3><p>配合:before（插入元素之前）:after（插入元素之后）使用<br><strong> 值：</strong><br>none<br>attr()插入标签属性值</p>
<pre><code>a:before{
    content:attr(title); 
}
&lt;a href=&quot;#&quot; title=&quot;我要插进去&quot;&gt;  
</code></pre><p>url()插入外部资源<br>string插入字符串（直接插字符串）eg:content:”插”；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/css3/" data-id="cjnbhxifa0001zghomc3v5w4u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-cil" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/vue-cil/" class="article-date">
  <time datetime="2018-10-16T04:26:13.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/vue-cil/">vue-cil</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code>npm install --global vue-cli
切换到项目目录
cd vuetest

安装一来模块
npm install
运行
npm run dev
打包
npm run build
</code></pre><p>main.js入口文件</p>
<pre><code>import Vue from &apos;vue&apos;
import todoList from &apos;./todoList.vue&apos;
</code></pre><p>new Vue({<br>    el：‘#app’,<br>    component:{todoList}<br>    template:’<todolist>‘<br>})</todolist></p>
<p>app.vue改为todoList 组件</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
    &lt;div&gt;
        &lt;input class=&quot;item&quot; v-model:&quot;inputValue&quot;&gt;
        &lt;button @click = &quot;handleSubmit&quot;&gt;提交&lt;/button&gt;
    &lt;/div&gt;
    &lt;ul&gt;
    &lt;todoItem v-for=&quot;{item,index } of list&quot; :key=&quot;index&quot; :content=&quot;item&quot; :index=&quot;index&quot; @delete = “myhandeldelete” &gt;&lt;/todoItem&gt;      //经过下面的组件声明方可使用 ，定义content目的父组件传值给子组件,监听delete事件触发此文件定义的myhandelDelete事件
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;//template中只能有一个子元素
&lt;script&gt;
import todoItem from &apos;./component/todoItem&apos;  //其为局部组件
export default{
    components:{
        &apos;todoItem&apos;:todoItem     //局部组件进行声明
    }
    data:function(){         //data从对象变成函数,其返回值对应的数据
        return {
        inputValue:&apos;&apos;,
        list:[]
        }
    },
    methods:{
        handelSubmit(){
            this.list.push(this.inputValue)  //this指向实例，vue底层将this.$data.list处理缩写成this.list
            this.inputvalue=&quot;&quot;
        },
        myhandelDelete(index){
            this.List.splice(index,1)
        }
    }    
}
&lt;/script&gt;
&lt;style&gt;&lt;/style&gt;
</code></pre><p>hellworld.vue==&gt;todoItem.vue</p>
<pre><code>&lt;template&gt;
    &lt;li class=&quot;item&quot; @click=&quot;handleDelete&quot;&gt;{{content}}&lt;/li&gt;
&lt;/template&gt;
&lt;script&gt;
    export default{
        props:[&apos;content&apos;,&apos;index&apos;], //声明对content的使用即接收名为content的数据
        methods:{
            handleDelete(){
                this.$emit(&apos;delete&apos;,this.index)//子组件向父组件通信,使用$emit向外触发事件delete,将this.index待会给父组件
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;    // scoped指组件作用域（局部样式）,组件外部的样式使用里面的内容没有作用
    .item{
        color
    }    
&lt;/style&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/vue-cil/" data-id="cjnbhxifp0006zghobpf8opjq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vuex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/vuex/" class="article-date">
  <time datetime="2018-10-16T03:55:33.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/vuex/">vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>new Vue({
//state
    data(){
        return{
            count:0
        }
    },
//view
    template:`&lt;div&gt;{{count}}&lt;/div&gt;`,
//actions
    methods:{
        increment(){
            this.count++
        }
    }
})
</code></pre><p>多个视图（<code>view</code>）需要依赖同一状态或不同视图更改同一状态时使用vuex,将组件的共享状态抽出，以一个全局单例模式管理，使任何组件都可获取状态和触发它</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>改变<code>store</code>唯一的途径就是提交（<code>store.commit(&#39;mutation定义的方法&#39;)</code>）<code>mutation</code>  </p>
<h3 id="组件调用store"><a href="#组件调用store" class="headerlink" title="组件调用store:"></a>组件调用store:</h3><p>由于store是响应式的，在组件中调用Store中的状态只需在计算属性中返回</p>
<pre><code>const Counter = {
    template:`&lt;div&gt;count&lt;/div&gt;`,
    computed:{
        count(){
            return store.state.count
        }
    }
}
</code></pre><p>为防止每个组件频繁导入state，将根组件“注入”到每个子组件中（需要调用Vue.use(Vuex)）子组件在computed中通过<code>this.$store</code>访问</p>
<pre><code>const app = new Vue({
    el:&quot;#app&quot;,
    store,
    //调用store项，可以把Store实例注入所有的子组件
    components:{Counter},
    template:`
        &lt;div class=&quot;app&quot;&gt;
            &lt;counter&gt;&lt;/counter&gt;
        &lt;/div&gt;

    `
})
</code></pre><p>当一个组件需要获取多个状态</p>
<pre><code>import {mapState} from &apos;vuex&apos;
export default{
    computed:mapState({
        //count函数返回状态中的属性
        count:state=&gt;state.count
        //将字符串参数&apos;count&apos;等同于‘state=&gt;state.count’
        countAlias:&apos;count&apos;
        countPlusLocalState(state){
         // 为了能够使用 `this` 获取局部状态，必须使用常规函数
            return state.count+this.localCount
        }
    })    
} 
</code></pre><p>..</p>
<pre><code>computed:mapState([&apos;count&apos;])
//映射this.count为store.state.count
</code></pre><p>将<code>mapstate</code>与局部计算属性混合使用对象展开运算符</p>
<h3 id="组件触发变化"><a href="#组件触发变化" class="headerlink" title="组件触发变化:"></a>组件触发变化:</h3><p>在methods中提交mutation</p>
<h2 id="getters（store的计算属性）"><a href="#getters（store的计算属性）" class="headerlink" title="getters（store的计算属性）"></a>getters（store的计算属性）</h2><p>依赖发生变化才会重新计算</p>
<pre><code>const store = new Vuex.Store({
    state:{
        todos:[
        {id:1,text:&apos;...&apos;,done:true},
        {id:1,text:&apos;...&apos;,done:false}
        ]
    },
    getters:{
        doneTodos:state=&gt;{
            return state.todos.filter(todo=&gt;todo.done)
        },
        doneTodosCount:(state,getters)=&gt;{
                return getters.doneTodos.length
            }
        //getter接收其他getter作为第二参数
        },
        getTodoById:(state)=&gt;(id)=&gt;{
            return state.todos.find(todo=&gt;todo)
        }
        //给getter中的方法传参
    }
})
</code></pre><h4 id="以属性的形式访问值"><a href="#以属性的形式访问值" class="headerlink" title="以属性的形式访问值"></a>以属性的形式访问值</h4><pre><code>store.getters.doneTodos // -&gt; [{ id: 1, text: &apos;...&apos;, done: true }]
store.getters.doneTodosCount // -&gt; 1
store.getters.getTodoById(2) // -&gt; { id: 2, text: &apos;...&apos;, done: false }
</code></pre><p>在组件中使用它</p>
<pre><code>computed:{
    doneTodisCount(){
        return this.$store.getter.doneTodoCount
    }
}
</code></pre><h3 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h3><p>将getter映射到局部计算属性：</p>
<pre><code>import {mapGetters} from &apos;vuex&apos;
export default{
    computed:{
        ...mapGetters([
                doneCount:&apos;doneTodosCount&apos;,
                &apos;antherGetter&apos;//默认用原名
        ])
    }
}    
</code></pre><h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><p>必须是同步函数<br>任何在回调函数中进行的状态的改变都是不可追踪的</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,n){
            state.count += n ;
        }
    }    
})
</code></pre><p>不能直接调用mutation handler，这个选项类似事件注册：“当触发一个type(类型为increment)的mutation时，调用函数”，因此使用store.commit传入相应的type</p>
<pre><code>store.commit(&apos;increment&apos;,22)
</code></pre><h3 id="payload将n换成payload对象即可"><a href="#payload将n换成payload对象即可" class="headerlink" title="payload将n换成payload对象即可"></a>payload将n换成payload对象即可</h3><p>传入对象</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,payload){
            state.count += payload.amount ;
        }
    }    
})
store.commit(&apos;increment&apos;,{
    amount:10
})    
---------------------------------
//或者
//提交mutation的另一种方式（对象风格）
    store.commit({
        type:&apos;increment&apos;,
        amount:10
    })
</code></pre><h3 id="store的state添加新属性"><a href="#store的state添加新属性" class="headerlink" title="store的state添加新属性"></a>store的state添加新属性</h3><pre><code>Vue.set(obj,&apos;newProp&apos;,123)
-----------或者
state.obj = {...state.obj,newProp:123}
</code></pre><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>使用<code>mapMutations</code>将组件中的methods映射为store.commit调用（需要在根节点注入store）</p>
<pre><code>import {mapMutations} from &apos;vuex&apos;
export default{
    methods:{
        ...mapMutations({
            ‘increment’,//将`this.increment`映射为`this.$store.commit(increment)`  
            &apos;incrementBy&apos; 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`
        }),
        ...mapMutations({
            add:&apos;increment&apos; //将this.add()映射为`this.$store.commit(&apos;increment&apos;)`
        })
    }
}
</code></pre><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>1.提交的是mutation2.可以进行异步操作</p>
<pre><code>const store = new Vuex.store({
    state:{
        count:0
    },
    mutation:{
        increment(state){
            state.count++;
        }
    },
    action:{
        incrementAsync({commit}){ //参数解构 ==》context.commit==&gt;context类似store实例
            setTimeout(()=&gt;{
                commit(&apos;increment&apos;)
            },1000)  //进行异步操作
        }
    }
})
</code></pre><h3 id="分发方式通过store-dispatch触发（类似于store-commit-）"><a href="#分发方式通过store-dispatch触发（类似于store-commit-）" class="headerlink" title="分发方式通过store.dispatch触发（类似于store.commit()）"></a>分发方式通过store.dispatch触发（类似于store.commit()）</h3><pre><code>store.dispatch(&apos;incrementAsync&apos;,{amount:10})
//同样支持以对象形式分发
store.dispatch({
    type:&apos;incrementAsync&apos;,
    amount:10
})
</code></pre><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><pre><code>import {mapActions} from &apos;vuex&apos;
export default{
    methods:{
        ...mapActions([
            &apos;increment&apos;,//将`this.increment()`映射为`this.$store.dispatch(&apos;increment&apos;)`
        ]),
        ...mapActions({
            add:&apos;increment&apos;//将`this.add()`映射为`this.$store.dispatch(increment)`
        })
    }
}
</code></pre><h3 id="组合Action"><a href="#组合Action" class="headerlink" title="组合Action"></a>组合Action</h3><p>store.dispatch可以处理被触发的action的处理函数返回promise并且store.dispatch仍旧返回promise</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    }
}
</code></pre><hr>
<pre><code>store.dispatch(&apos;actionA&apos;).then(()=&gt;{...})
</code></pre><p>在另一个action中调用action</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    },
    actionB({dispatch,commit}){
        return dispatch(&apos;actionA&apos;).then(()=&gt;{
            commit(&apos;someOtherMutation&apos;)
        })
    }
}
</code></pre><p>使用asych/await</p>
<pre><code>actions:{
    async actionA({commit}){
        commit(&apos;gotAta&apos;,await getDate())
    },
    async actionA({dispatch,commit}){
        await dispatch(&apos;actionA&apos;)
        commit(&apos;gotOtherAta&apos;,await getOtherDate())
    }
}
</code></pre><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>将store分割成模块，每个模块拥有自己的<code>state</code>,<code>mutation</code>,<code>action</code>,<code>getter</code>,甚至嵌套子模块</p>
<pre><code>const moduleA = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const moduleB = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const store = new Vuex.Store({
    models:{
        a:moduleA,
        b:moduleB
    }
})
</code></pre><h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>mutation和getters接收的第一个参数（state）是局部的<br>对于action和getters通过第三个参数暴露出来：({state,commit,<code>rootState</code>|<code>rootGetter</code>})<br>分发时将{root:true}作第三参数传给dispatch得到全局</p>
<h3 id="命名空间namespaces-true"><a href="#命名空间namespaces-true" class="headerlink" title="命名空间namespaces:true"></a>命名空间namespaces:true</h3><pre><code>modules: {
  foo: {  //命名空间
    namespaced: true,

    getters: {
      // 在这个模块的 getter 中，`getters` 被局部化了
      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter // -&gt; &apos;foo/someOtherGetter&apos;
        rootGetters.someOtherGetter // -&gt; &apos;someOtherGetter&apos;
      },
      someOtherGetter: state =&gt; { ... }
    },

    actions: {
      // 在这个模块中， dispatch 和 commit 也被局部化了
      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter // -&gt; &apos;foo/someGetter&apos;
        rootGetters.someGetter // -&gt; &apos;someGetter&apos;

        dispatch(&apos;someOtherAction&apos;) // -&gt; &apos;foo/someOtherAction&apos;
        dispatch(&apos;someOtherAction&apos;, null, { root: true }) // -&gt; &apos;someOtherAction&apos;

        commit(&apos;someMutation&apos;) // -&gt; &apos;foo/someMutation&apos;
        commit(&apos;someMutation&apos;, null, { root: true }) // -&gt; &apos;someMutation&apos;
      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}
</code></pre><h3 id="在命名空间模块中注册全局action"><a href="#在命名空间模块中注册全局action" class="headerlink" title="在命名空间模块中注册全局action"></a>在命名空间模块中注册全局action</h3><p>添加root:true并将这个action放在handler中</p>
<pre><code>{
    actions:{
        someOtherAcrion({dispatch}){
            dispatch(&apos;someAction&apos;)    
        }
    },
    modules:{
        foo:{
            namespaced:true,
            actions:{
                someAction:{
                    `root:true`,
                    handler(namespacedContext,payload){...}
                }
            }
        }
    }
}
</code></pre><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>由于命名空间的存在mapState,maoGetters,mapActions,mapMutations绑定命名空间起来比较繁琐</p>
<pre><code>computed:{
    ...mapState({
        a:state =&gt;state.some.nested.module.a
    })
},    
methods:{
    ...mapActions([
        &apos;some/nested/module/foo&apos;
    ])
}
</code></pre><p>可以简化为</p>
<pre><code>computed: {
  ...mapState(&apos;some/nested/module&apos;, {   //空间名称字符串作为第一个参数传递给函数
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions(&apos;some/nested/module&apos;, [
    &apos;foo&apos;,
    &apos;bar&apos;
  ])
}
</code></pre><h4 id="createNamespacedHelpers命名空间辅助函数。它返回一个对象"><a href="#createNamespacedHelpers命名空间辅助函数。它返回一个对象" class="headerlink" title="createNamespacedHelpers命名空间辅助函数。它返回一个对象"></a>createNamespacedHelpers命名空间辅助函数。它返回一个对象</h4><pre><code>import { createNamespacedHelpers } from &apos;vuex&apos;

***const { mapState, mapActions } = createNamespacedHelpers(&apos;some/nested/module&apos;)

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state =&gt; state.a,
      b: state =&gt; state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      &apos;foo&apos;,
      &apos;bar&apos;
    ])
  }
}
</code></pre><h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><pre><code>store.registerModule(&apos;myMoudule&apos;,{
    ...
})//注册模块`myModule`
store.registerModule([&apos;nested&apos;,&apos;myMoudel&apos;]),{
    ...
}//注册嵌套模`nested/myModule`
</code></pre><p>通过store.state.myMoudel和store.state.nested.myMoudel访问</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/vuex/" data-id="cjnbhxifq0007zghob95y77yn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-async-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/async-1/" class="article-date">
  <time datetime="2018-10-16T03:46:00.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/async-1/">async</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><pre><code>const asyncReadFile = async function () {
  const f1 = await readFile(&apos;/etc/fstab&apos;);
  const f2 = await readFile(&apos;/etc/shells&apos;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre><ul>
<li>async表示函数里有异步操作，asyn，await后的函数会返回一个Promise 对象，,await命令就是内部then命令的语法糖  </li>
<li>await会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
<li><p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<pre><code>async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
}

getStockPriceByName(&apos;goog&apos;).then(function (result) {
  console.log(result);
});
</code></pre></li>
<li><p>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><pre><code>async function f() {
  try {
    await new Promise(function (resolve, reject) {
      throw new Error(&apos;出错了&apos;);
    });
  } catch(e) {
  }
  return await(&apos;hello world&apos;);
}

//另一种写法
async function myFunction() {
  await somethingThatReturnsAPromise()
  .catch(function (err) {
    console.log(err);
  });
}
</code></pre><h2 id="同时触发"><a href="#同时触发" class="headerlink" title="同时触发"></a>同时触发</h2><p>  let [foo, bar] = await Promise.all([getFoo(), getBar()]);</p>
<p>  // 写法二<br>  let fooPromise = getFoo();<br>  let barPromise = getBar();<br>  let foo = await fooPromise;<br>  let bar = await barPromise;</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/async-1/" data-id="cjnbhxif30000zgho2n1fbewg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/this/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/this/">关于this指向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>this指的是调用当前方法（函数）的那个对象 </p>
<h2 id="一-无参数函数this的指向"><a href="#一-无参数函数this的指向" class="headerlink" title="一.无参数函数this的指向"></a>一.无参数函数this的指向</h2><p><code>function fn1(){  alert(this)  }</code>  </p>
<pre><code>fn1()   ===》window   
oBtn.onclick = fn1;   ===&gt; oBtn    
oBtn.onclick = function(){ this };   ===&gt; oBtn    
oBtn.onclick = function(){ fn() };   ===&gt; window
 oBtn.onclick = function(){ fn(this) };   ===&gt; oBtn
`&lt;button  onclick = &quot;alert(this  fn(1))&quot;&gt;&lt;/button&gt;`      this===&gt;button    fn1()里的this===&gt;window   
</code></pre><h2 id="二-、带参数函数this的指向"><a href="#二-、带参数函数this的指向" class="headerlink" title="二.、带参数函数this的指向"></a>二.、带参数函数this的指向</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre><code>fn1(this)  
function fn1(obj){  obj  }  obj===window    
</code></pre><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre><code>oDiv.onclick = function{
fn1(this) 
}  
function fn1(obj){
obj
}    obj ===》oDiv   
</code></pre><h2 id="三-当this指向window时用that存储"><a href="#三-当this指向window时用that存储" class="headerlink" title="三.当this指向window时用that存储"></a>三.当this指向window时用that存储</h2><pre><code>var that = null;
oBtn.onclick = function(){
that = this;
fn1();
}
fn1(){
that.style.background = &apos;yellow&apos;; 
}    
===》this指向oBtn
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/this/" data-id="cjnbhxifo0005zgho1f29bruu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/闭包/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数作为返回值被返回"><a href="#函数作为返回值被返回" class="headerlink" title="函数作为返回值被返回"></a>函数作为返回值被返回</h2><pre><code>function F(){
    var a = 1;
    function foo(){
        return a;
    }
    return foo;
}        
console.log(F()());   
</code></pre><h2 id="函数被赋给一个变量"><a href="#函数被赋给一个变量" class="headerlink" title="函数被赋给一个变量"></a>函数被赋给一个变量</h2><pre><code>var ret;
function F(){
    var a = 1;
    function foo(){
        return a;
    }
    ret = foo;
}
F()          
console.log(ret());
</code></pre><p>作用：<br>在在作用域以外的地方（全局作用域)中执行函数，但函数有其特定的作用域</p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><pre><code>function inner(fn){
    console.log(fn());    
}
(function(){
var a = 1;
function foo(){
    return a;
}
inner(foo)
 })()
</code></pre><p>在立即执行函数中被声明（作用域）,在inner函数中被调用    </p>
<h2 id="循环问题"><a href="#循环问题" class="headerlink" title="循环问题"></a>循环问题</h2><pre><code>function foo(){
    var arr = [];
    for(var i = 0;i&lt;2;i++){
        arr[i] = function(){
            return i;
        }
    }
    return arr;
}
var bar = foo();
console.log(bar[0]());
</code></pre><p>:<img src="root.png" alt=""></p>
<h3 id="使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值"><a href="#使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值" class="headerlink" title="使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值"></a>使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值</h3><pre><code>function foo(){
    var arr =  [] ;
    for(var i = 0;i&lt;2;i++){
        arr[i] = (function(j){
            return function test(){
                return j;
            }
        })(i)
    }
return arr;
}
var bar = foo();
console.log(bar[0]());
</code></pre><p>:<img src="roott.png" alt=""></p>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>循环中的变量使用let</p>
<h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter||setter"></a>getter||setter</h2><p>通过setValue和getValue将要操作的变量保存在函数内部，防止暴露在外部</p>
<pre><code>var getValule,setValue
(function(){
var a = 0;
getValue = function(){
    return a;
}
setValue = function(i){
    if(typeof i === &apos;number&apos;){
        a = i;
    }
}
})()
console.log(getValue());
setValue(1);
console.log(getValue());
</code></pre><h2 id="使用闭包实现迭代器"><a href="#使用闭包实现迭代器" class="headerlink" title="使用闭包实现迭代器"></a>使用闭包实现迭代器</h2><pre><code>function F(arr){
    var i = 0;
    return function(){
        return arr[i++]
    } 
}
var next = F([1,2,3]);
console.log(next());//1
console.log(next());//2
</code></pre><h2 id="使用闭包区分首次"><a href="#使用闭包区分首次" class="headerlink" title="使用闭包区分首次"></a>使用闭包区分首次</h2><pre><code>var firstLoad = (function(id){
var list = [];
return function(id){
    if(list.indexOf(id) &gt;= 0){
        return false;
    }else{
        list.push(id);
        return true;
    }
}
})();
console.log(firstLoad(10));
console.log(firstLoad(10));
console.log(firstLoad(2));
</code></pre><h2 id="模拟缓存机制"><a href="#模拟缓存机制" class="headerlink" title="模拟缓存机制"></a>模拟缓存机制</h2><pre><code>var mult = function(){
var cache = {};
var calculate = function(){
    var a = 1;
    console.log(arguments);
    for(var i = 0,len = arguments.length;i&lt;len;i++){
        a = a*arguments[i];
    }
    return a;
}
return function(){
    var args = Array.prototype.join.call(arguments,&quot;,&quot;);//&quot;2,3&quot;
    if(args in cache){
        return cache[args];
    }
    cache[args] = calculate.apply(null,arguments);
    return cache[args];//6
}
}()
mult(2,3);
</code></pre><p>如果参数在缓存中存在，直接从缓存中取，如果不存在放入缓存中</p>
<h2 id="Ping图像数据上报"><a href="#Ping图像数据上报" class="headerlink" title="Ping图像数据上报"></a>Ping图像数据上报</h2><p>还记得跨域请求中的<img>标签实现的单向通信吗</p>
<pre><code>var    img = new Image();
    img.onload = img.onerror = function(){
        alert(&quot;Done!&quot;);
    } ;
    img.src = &quot;http://.....&quot;;
</code></pre><p>现在我们将其封装在一个函数中</p>
<pre><code>var report = function(src){
  var img = new Image();
  img.src = src;
}
report(&apos;http://xx.com/getUserInfo&apos;);
</code></pre><p>但是这样可能会导致数据上报不完全，因为当函数调用完以后，img变量就销毁，有可能现在还没有来得及发送HTTP请求哟~<br>因此我们把img变量用闭包封装起来</p>
<pre><code>var report = (function(){
var imgs = [];
return function(src){
    var    img = new Image();
    img.onload = img.onerror = function(){
        alert(&quot;Done!&quot;);
    } ;
    img.src = src;
}
})()
report(&quot;http://.....&quot;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/闭包/" data-id="cjnbhxifs0008zghob7duggv3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/16/scope/">scope</a>
          </li>
        
          <li>
            <a href="/2018/10/16/draw/">Canvas和SVG的区别</a>
          </li>
        
          <li>
            <a href="/2018/10/16/datastore/">浏览器存储技术</a>
          </li>
        
          <li>
            <a href="/2018/10/16/css3/">css3</a>
          </li>
        
          <li>
            <a href="/2018/10/16/vue-cil/">vue-cil</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>