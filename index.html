<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shelly-Shen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="shelly&apos;s blog ———— share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="Shelly-Shen">
<meta property="og:url" content="http://Shelly-Shen.github.io/index.html">
<meta property="og:site_name" content="Shelly-Shen">
<meta property="og:description" content="shelly&apos;s blog ———— share everything">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shelly-Shen">
<meta name="twitter:description" content="shelly&apos;s blog ———— share everything">
  
    <link rel="alternate" href="/atom.xml" title="Shelly-Shen" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shelly-Shen</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Shelly-Shen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vuex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/vuex/" class="article-date">
  <time datetime="2018-10-16T03:55:33.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/vuex/">vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>new Vue({
//state
    data(){
        return{
            count:0
        }
    },
//view
    template:`&lt;div&gt;{{count}}&lt;/div&gt;`,
//actions
    methods:{
        increment(){
            this.count++
        }
    }
})
</code></pre><p>多个视图（<code>view</code>）需要依赖同一状态或不同视图更改同一状态时使用vuex,将组件的共享状态抽出，以一个全局单例模式管理，使任何组件都可获取状态和触发它</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>改变<code>store</code>唯一的途径就是提交（<code>store.commit(&#39;mutation定义的方法&#39;)</code>）<code>mutation</code>  </p>
<h3 id="组件调用store"><a href="#组件调用store" class="headerlink" title="组件调用store:"></a>组件调用store:</h3><p>由于store是响应式的，在组件中调用Store中的状态只需在计算属性中返回</p>
<pre><code>const Counter = {
    template:`&lt;div&gt;count&lt;/div&gt;`,
    computed:{
        count(){
            return store.state.count
        }
    }
}
</code></pre><p>为防止每个组件频繁导入state，将根组件“注入”到每个子组件中（需要调用Vue.use(Vuex)）子组件在computed中通过<code>this.$store</code>访问</p>
<pre><code>const app = new Vue({
    el:&quot;#app&quot;,
    store,
    //调用store项，可以把Store实例注入所有的子组件
    components:{Counter},
    template:`
        &lt;div class=&quot;app&quot;&gt;
            &lt;counter&gt;&lt;/counter&gt;
        &lt;/div&gt;

    `
})
</code></pre><p>当一个组件需要获取多个状态</p>
<pre><code>import {mapState} from &apos;vuex&apos;
export default{
    computed:mapState({
        //count函数返回状态中的属性
        count:state=&gt;state.count
        //将字符串参数&apos;count&apos;等同于‘state=&gt;state.count’
        countAlias:&apos;count&apos;
        countPlusLocalState(state){
         // 为了能够使用 `this` 获取局部状态，必须使用常规函数
            return state.count+this.localCount
        }
    })    
} 
</code></pre><p>..</p>
<pre><code>computed:mapState([&apos;count&apos;])
//映射this.count为store.state.count
</code></pre><p>将<code>mapstate</code>与局部计算属性混合使用对象展开运算符</p>
<h3 id="组件触发变化"><a href="#组件触发变化" class="headerlink" title="组件触发变化:"></a>组件触发变化:</h3><p>在methods中提交mutation</p>
<h2 id="getters（store的计算属性）"><a href="#getters（store的计算属性）" class="headerlink" title="getters（store的计算属性）"></a>getters（store的计算属性）</h2><p>依赖发生变化才会重新计算</p>
<pre><code>const store = new Vuex.Store({
    state:{
        todos:[
        {id:1,text:&apos;...&apos;,done:true},
        {id:1,text:&apos;...&apos;,done:false}
        ]
    },
    getters:{
        doneTodos:state=&gt;{
            return state.todos.filter(todo=&gt;todo.done)
        },
        doneTodosCount:(state,getters)=&gt;{
                return getters.doneTodos.length
            }
        //getter接收其他getter作为第二参数
        },
        getTodoById:(state)=&gt;(id)=&gt;{
            return state.todos.find(todo=&gt;todo)
        }
        //给getter中的方法传参
    }
})
</code></pre><h4 id="以属性的形式访问值"><a href="#以属性的形式访问值" class="headerlink" title="以属性的形式访问值"></a>以属性的形式访问值</h4><pre><code>store.getters.doneTodos // -&gt; [{ id: 1, text: &apos;...&apos;, done: true }]
store.getters.doneTodosCount // -&gt; 1
store.getters.getTodoById(2) // -&gt; { id: 2, text: &apos;...&apos;, done: false }
</code></pre><p>在组件中使用它</p>
<pre><code>computed:{
    doneTodisCount(){
        return this.$store.getter.doneTodoCount
    }
}
</code></pre><h3 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h3><p>将getter映射到局部计算属性：</p>
<pre><code>import {mapGetters} from &apos;vuex&apos;
export default{
    computed:{
        ...mapGetters([
                doneCount:&apos;doneTodosCount&apos;,
                &apos;antherGetter&apos;//默认用原名
        ])
    }
}    
</code></pre><h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><p>必须是同步函数<br>任何在回调函数中进行的状态的改变都是不可追踪的</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,n){
            state.count += n ;
        }
    }    
})
</code></pre><p>不能直接调用mutation handler，这个选项类似事件注册：“当触发一个type(类型为increment)的mutation时，调用函数”，因此使用store.commit传入相应的type</p>
<pre><code>store.commit(&apos;increment&apos;,22)
</code></pre><h3 id="payload将n换成payload对象即可"><a href="#payload将n换成payload对象即可" class="headerlink" title="payload将n换成payload对象即可"></a>payload将n换成payload对象即可</h3><p>传入对象</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,payload){
            state.count += payload.amount ;
        }
    }    
})
store.commit(&apos;increment&apos;,{
    amount:10
})    
---------------------------------
//或者
//提交mutation的另一种方式（对象风格）
    store.commit({
        type:&apos;increment&apos;,
        amount:10
    })
</code></pre><h3 id="store的state添加新属性"><a href="#store的state添加新属性" class="headerlink" title="store的state添加新属性"></a>store的state添加新属性</h3><pre><code>Vue.set(obj,&apos;newProp&apos;,123)
-----------或者
state.obj = {...state.obj,newProp:123}
</code></pre><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>使用<code>mapMutations</code>将组件中的methods映射为store.commit调用（需要在根节点注入store）</p>
<pre><code>import {mapMutations} from &apos;vuex&apos;
export default{
    methods:{
        ...mapMutations({
            ‘increment’,//将`this.increment`映射为`this.$store.commit(increment)`  
            &apos;incrementBy&apos; 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`
        }),
        ...mapMutations({
            add:&apos;increment&apos; //将this.add()映射为`this.$store.commit(&apos;increment&apos;)`
        })
    }
}
</code></pre><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>1.提交的是mutation2.可以进行异步操作</p>
<pre><code>const store = new Vuex.store({
    state:{
        count:0
    },
    mutation:{
        increment(state){
            state.count++;
        }
    },
    action:{
        incrementAsync({commit}){ //参数解构 ==》context.commit==&gt;context类似store实例
            setTimeout(()=&gt;{
                commit(&apos;increment&apos;)
            },1000)  //进行异步操作
        }
    }
})
</code></pre><h3 id="分发方式通过store-dispatch触发（类似于store-commit-）"><a href="#分发方式通过store-dispatch触发（类似于store-commit-）" class="headerlink" title="分发方式通过store.dispatch触发（类似于store.commit()）"></a>分发方式通过store.dispatch触发（类似于store.commit()）</h3><pre><code>store.dispatch(&apos;incrementAsync&apos;,{amount:10})
//同样支持以对象形式分发
store.dispatch({
    type:&apos;incrementAsync&apos;,
    amount:10
})
</code></pre><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><pre><code>import {mapActions} from &apos;vuex&apos;
export default{
    methods:{
        ...mapActions([
            &apos;increment&apos;,//将`this.increment()`映射为`this.$store.dispatch(&apos;increment&apos;)`
        ]),
        ...mapActions({
            add:&apos;increment&apos;//将`this.add()`映射为`this.$store.dispatch(increment)`
        })
    }
}
</code></pre><h3 id="组合Action"><a href="#组合Action" class="headerlink" title="组合Action"></a>组合Action</h3><p>store.dispatch可以处理被触发的action的处理函数返回promise并且store.dispatch仍旧返回promise</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    }
}
</code></pre><hr>
<pre><code>store.dispatch(&apos;actionA&apos;).then(()=&gt;{...})
</code></pre><p>在另一个action中调用action</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    },
    actionB({dispatch,commit}){
        return dispatch(&apos;actionA&apos;).then(()=&gt;{
            commit(&apos;someOtherMutation&apos;)
        })
    }
}
</code></pre><p>使用asych/await</p>
<pre><code>actions:{
    async actionA({commit}){
        commit(&apos;gotAta&apos;,await getDate())
    },
    async actionA({dispatch,commit}){
        await dispatch(&apos;actionA&apos;)
        commit(&apos;gotOtherAta&apos;,await getOtherDate())
    }
}
</code></pre><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>将store分割成模块，每个模块拥有自己的<code>state</code>,<code>mutation</code>,<code>action</code>,<code>getter</code>,甚至嵌套子模块</p>
<pre><code>const moduleA = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const moduleB = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const store = new Vuex.Store({
    models:{
        a:moduleA,
        b:moduleB
    }
})
</code></pre><h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>mutation和getters接收的第一个参数（state）是局部的<br>对于action和getters通过第三个参数暴露出来：({state,commit,<code>rootState</code>|<code>rootGetter</code>})<br>分发时将{root:true}作第三参数传给dispatch得到全局</p>
<h3 id="命名空间namespaces-true"><a href="#命名空间namespaces-true" class="headerlink" title="命名空间namespaces:true"></a>命名空间namespaces:true</h3><pre><code>modules: {
  foo: {  //命名空间
    namespaced: true,

    getters: {
      // 在这个模块的 getter 中，`getters` 被局部化了
      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter // -&gt; &apos;foo/someOtherGetter&apos;
        rootGetters.someOtherGetter // -&gt; &apos;someOtherGetter&apos;
      },
      someOtherGetter: state =&gt; { ... }
    },

    actions: {
      // 在这个模块中， dispatch 和 commit 也被局部化了
      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter // -&gt; &apos;foo/someGetter&apos;
        rootGetters.someGetter // -&gt; &apos;someGetter&apos;

        dispatch(&apos;someOtherAction&apos;) // -&gt; &apos;foo/someOtherAction&apos;
        dispatch(&apos;someOtherAction&apos;, null, { root: true }) // -&gt; &apos;someOtherAction&apos;

        commit(&apos;someMutation&apos;) // -&gt; &apos;foo/someMutation&apos;
        commit(&apos;someMutation&apos;, null, { root: true }) // -&gt; &apos;someMutation&apos;
      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}
</code></pre><h3 id="在命名空间模块中注册全局action"><a href="#在命名空间模块中注册全局action" class="headerlink" title="在命名空间模块中注册全局action"></a>在命名空间模块中注册全局action</h3><p>添加root:true并将这个action放在handler中</p>
<pre><code>{
    actions:{
        someOtherAcrion({dispatch}){
            dispatch(&apos;someAction&apos;)    
        }
    },
    modules:{
        foo:{
            namespaced:true,
            actions:{
                someAction:{
                    `root:true`,
                    handler(namespacedContext,payload){...}
                }
            }
        }
    }
}
</code></pre><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>由于命名空间的存在mapState,maoGetters,mapActions,mapMutations绑定命名空间起来比较繁琐</p>
<pre><code>computed:{
    ...mapState({
        a:state =&gt;state.some.nested.module.a
    })
},    
methods:{
    ...mapActions([
        &apos;some/nested/module/foo&apos;
    ])
}
</code></pre><p>可以简化为</p>
<pre><code>computed: {
  ...mapState(&apos;some/nested/module&apos;, {   //空间名称字符串作为第一个参数传递给函数
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions(&apos;some/nested/module&apos;, [
    &apos;foo&apos;,
    &apos;bar&apos;
  ])
}
</code></pre><h4 id="createNamespacedHelpers命名空间辅助函数。它返回一个对象"><a href="#createNamespacedHelpers命名空间辅助函数。它返回一个对象" class="headerlink" title="createNamespacedHelpers命名空间辅助函数。它返回一个对象"></a>createNamespacedHelpers命名空间辅助函数。它返回一个对象</h4><pre><code>import { createNamespacedHelpers } from &apos;vuex&apos;

***const { mapState, mapActions } = createNamespacedHelpers(&apos;some/nested/module&apos;)

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state =&gt; state.a,
      b: state =&gt; state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      &apos;foo&apos;,
      &apos;bar&apos;
    ])
  }
}
</code></pre><h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><pre><code>store.registerModule(&apos;myMoudule&apos;,{
    ...
})//注册模块`myModule`
store.registerModule([&apos;nested&apos;,&apos;myMoudel&apos;]),{
    ...
}//注册嵌套模`nested/myModule`
</code></pre><p>通过store.state.myMoudel和store.state.nested.myMoudel访问</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/vuex/" data-id="cjnb805pn000354ho1bh0xvkj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-async-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/async-1/" class="article-date">
  <time datetime="2018-10-16T03:46:00.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/async-1/">async</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><pre><code>const asyncReadFile = async function () {
  const f1 = await readFile(&apos;/etc/fstab&apos;);
  const f2 = await readFile(&apos;/etc/shells&apos;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre><ul>
<li>async表示函数里有异步操作，asyn，await后的函数会返回一个Promise 对象，,await命令就是内部then命令的语法糖  </li>
<li>await会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
<li><p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<pre><code>async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
}

getStockPriceByName(&apos;goog&apos;).then(function (result) {
  console.log(result);
});
</code></pre></li>
<li><p>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><pre><code>async function f() {
  try {
    await new Promise(function (resolve, reject) {
      throw new Error(&apos;出错了&apos;);
    });
  } catch(e) {
  }
  return await(&apos;hello world&apos;);
}

//另一种写法
async function myFunction() {
  await somethingThatReturnsAPromise()
  .catch(function (err) {
    console.log(err);
  });
}
</code></pre><h2 id="同时触发"><a href="#同时触发" class="headerlink" title="同时触发"></a>同时触发</h2><p>  let [foo, bar] = await Promise.all([getFoo(), getBar()]);</p>
<p>  // 写法二<br>  let fooPromise = getFoo();<br>  let barPromise = getBar();<br>  let foo = await fooPromise;<br>  let bar = await barPromise;</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/async-1/" data-id="cjnb805pm000254ho45sz07ok" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue.cil" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/vue.cil/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/vue.cil/">vue.cli</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###创建</p>
<pre><code>npm install --global vue-cli
切换到项目目录
cd vuetest

安装一来模块
npm install
运行
npm run dev
打包
npm run build
</code></pre><p>main.js入口文件</p>
<pre><code>import Vue from &apos;vue&apos;
import todoList from &apos;./todoList.vue&apos;
</code></pre><p>new Vue({<br>    el：‘#app’,<br>    component:{todoList}<br>    template:’<todolist>‘<br>})</todolist></p>
<p>app.vue改为todoList 组件</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
    &lt;div&gt;
        &lt;input class=&quot;item&quot; v-model:&quot;inputValue&quot;&gt;
        &lt;button @click = &quot;handleSubmit&quot;&gt;提交&lt;/button&gt;
    &lt;/div&gt;
    &lt;ul&gt;
    &lt;todoItem v-for=&quot;{item,index } of list&quot; :key=&quot;index&quot; :content=&quot;item&quot; :index=&quot;index&quot; @delete = “myhandeldelete” &gt;&lt;/todoItem&gt;      //经过下面的组件声明方可使用 ，定义content目的父组件传值给子组件,监听delete事件触发此文件定义的myhandelDelete事件
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;//template中只能有一个子元素
&lt;script&gt;
import todoItem from &apos;./component/todoItem&apos;  //其为局部组件
export default{
    components:{
        &apos;todoItem&apos;:todoItem     //局部组件进行声明
    }
    data:function(){         //data从对象变成函数,其返回值对应的数据
        return {
        inputValue:&apos;&apos;,
        list:[]
        }
    },
    methods:{
        handelSubmit(){
            this.list.push(this.inputValue)  //this指向实例，vue底层将this.$data.list处理缩写成this.list
            this.inputvalue=&quot;&quot;
        },
        myhandelDelete(index){
            this.List.splice(index,1)
        }
    }    
}
&lt;/script&gt;
&lt;style&gt;&lt;/style&gt;
</code></pre><p>hellworld.vue==&gt;todoItem.vue</p>
<pre><code>&lt;template&gt;
    &lt;li class=&quot;item&quot; @click=&quot;handleDelete&quot;&gt;{{content}}&lt;/li&gt;
&lt;/template&gt;
&lt;script&gt;
    export default{
        props:[&apos;content&apos;,&apos;index&apos;], //声明对content的使用即接收名为content的数据
        methods:{
            handleDelete(){
                this.$emit(&apos;delete&apos;,this.index)//子组件向父组件通信,使用$emit向外触发事件delete,将this.index待会给父组件
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;    // scoped指组件作用域（局部样式）,组件外部的样式使用里面的内容没有作用
    .item{
        color
    }    
&lt;/style&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/vue.cil/" data-id="cjnb805pe000054hoobayjrnu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-作用域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/作用域/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/作用域/">作用域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>域：空间，范围，区域….  (除函数，if for 都不是作用域)<br>作用：读，写<br>浏览器：  “JS解析器”<br>域：   1）Script:全局变量，全局函数<br>自上而下<br>2）函数 ：由里到外</p>
<h3 id="1-“找一些东西”：var-function-参数"><a href="#1-“找一些东西”：var-function-参数" class="headerlink" title="1.“找一些东西”：var function 参数"></a>1.“找一些东西”：var function 参数</h3><pre><code>a=未定义   所有的变量在正式运行代码之前都提前赋了个值：未定义
fn1=function(){alert(1);}
</code></pre><p>所有的函数，在正式运行代码之前，都是整个函数块<br>JS的预解析      遇到重名的：只留一个<br>变量和函数重名只留函数  （全局域2.）</p>
<h3 id="2-逐行解析代码"><a href="#2-逐行解析代码" class="headerlink" title="2.逐行解析代码:"></a>2.逐行解析代码:</h3><h4 id="1-表达式-–-参数…-能够改变值得东西-，动作"><a href="#1-表达式-–-参数…-能够改变值得东西-，动作" class="headerlink" title="1)表达式: = + - * / % ++ – ! 参数….(能够改变值得东西 ，动作)"></a>1)表达式: = + - * / % ++ – ! 参数….(能够改变值得东西 ，动作)</h4><p>表达式可以修改预解析的值</p>
<h4 id="2-函数调用-：-1-预解析：var-function-参数-2-逐行解析"><a href="#2-函数调用-：-1-预解析：var-function-参数-2-逐行解析" class="headerlink" title="2)函数调用 ： [1]预解析：var function 参数  [2]逐行解析"></a>2)函数调用 ： [1]预解析：var function 参数  [2]逐行解析</h4><pre><code>全局域 
1.
alert(a);//未定义
var a = 1;
function fn1(){alert(2);}（函数声明）


2.
alert(a);//function a(){alert(4);}
var a=1;
alert(a);//1
function a(){alert(2);}
alert(a);//1
var a=3;
alert(a);//3
function a(){alert(4);
alert(a);//3

局部域(局部域改变得值和全局中的无关)
1.var a=1;
 function fn1(){
 alert(a);//undefined 
 var a=2;
 }
 fn1();
 alert(a);//1  

2.var a=1;
 function fn1(){
 alert(a);  // 1 （预解析是找不到 a=...  没有变量 没有参数便向全局域中寻找） 
 a=2;   //在局部域中找不到预解析中的a 所以向全局域中寻找 从而改变全局域中的值
 }
 fn1();
 alert(a);//2  

3.参数  
 var a=1;
 function fn1(a){  //预解析成 a = ... 
 alert(a);//undefined
 var a=2;  //a=2
 }
 fn1();
 alert(a);//1
4.var a=1;
 function fn1(a){    //由于fn1(a) 预解析成 a = 1 
 alert(a);//1
 var a=2;  
 }
 fn1(a);
 alert(a);//1  （此时局部a和全局a并无关系）  
</code></pre><h3 id="小tip："><a href="#小tip：" class="headerlink" title="小tip："></a>小tip：</h3><p>想要哎获取函数内的值</p>
<h4 id="1-通过全局变量"><a href="#1-通过全局变量" class="headerlink" title="1.通过全局变量"></a>1.通过全局变量</h4><pre><code>var str = &apos;&apos;;
function fn1(){
var a=&apos;123&apos;;
str = a;
}    
fn1();
alert(str); 
</code></pre><h4 id="2-通过局部函数调用"><a href="#2-通过局部函数调用" class="headerlink" title="2.通过局部函数调用"></a>2.通过局部函数调用</h4><pre><code>function fn2(){
var a=&apos;123&apos;;
fn3(a);
}
fn2();
function fn3(a){
alert(a);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/作用域/" data-id="cjnb805pj000154howb556zho" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/闭包/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数作为返回值被返回"><a href="#函数作为返回值被返回" class="headerlink" title="函数作为返回值被返回"></a>函数作为返回值被返回</h2><pre><code>function F(){
    var a = 1;
    function foo(){
        return a;
    }
    return foo;
}        
console.log(F()());   
</code></pre><h2 id="函数被赋给一个变量"><a href="#函数被赋给一个变量" class="headerlink" title="函数被赋给一个变量"></a>函数被赋给一个变量</h2><pre><code>var ret;
function F(){
    var a = 1;
    function foo(){
        return a;
    }
    ret = foo;
}
F()          
console.log(ret());
</code></pre><p>作用：<br>在在作用域以外的地方（全局作用域)中执行函数，但函数有其特定的作用域</p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><pre><code>function inner(fn){
    console.log(fn());    
}
(function(){
var a = 1;
function foo(){
    return a;
}
inner(foo)
 })()
</code></pre><p>在立即执行函数中被声明（作用域）,在inner函数中被调用    </p>
<h2 id="循环问题"><a href="#循环问题" class="headerlink" title="循环问题"></a>循环问题</h2><pre><code>function foo(){
    var arr = [];
    for(var i = 0;i&lt;2;i++){
        arr[i] = function(){
            return i;
        }
    }
    return arr;
}
var bar = foo();
console.log(bar[0]());
</code></pre><p>:<img src="root.png" alt=""></p>
<h3 id="使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值"><a href="#使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值" class="headerlink" title="使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值"></a>使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值</h3><pre><code>function foo(){
    var arr =  [] ;
    for(var i = 0;i&lt;2;i++){
        arr[i] = (function(j){
            return function test(){
                return j;
            }
        })(i)
    }
return arr;
}
var bar = foo();
console.log(bar[0]());
</code></pre><p>:<img src="roott.png" alt=""></p>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>循环中的变量使用let</p>
<h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter||setter"></a>getter||setter</h2><p>通过setValue和getValue将要操作的变量保存在函数内部，防止暴露在外部</p>
<pre><code>var getValule,setValue
(function(){
var a = 0;
getValue = function(){
    return a;
}
setValue = function(i){
    if(typeof i === &apos;number&apos;){
        a = i;
    }
}
})()
console.log(getValue());
setValue(1);
console.log(getValue());
</code></pre><h2 id="使用闭包实现迭代器"><a href="#使用闭包实现迭代器" class="headerlink" title="使用闭包实现迭代器"></a>使用闭包实现迭代器</h2><pre><code>function F(arr){
    var i = 0;
    return function(){
        return arr[i++]
    } 
}
var next = F([1,2,3]);
console.log(next());//1
console.log(next());//2
</code></pre><h2 id="使用闭包区分首次"><a href="#使用闭包区分首次" class="headerlink" title="使用闭包区分首次"></a>使用闭包区分首次</h2><pre><code>var firstLoad = (function(id){
var list = [];
return function(id){
    if(list.indexOf(id) &gt;= 0){
        return false;
    }else{
        list.push(id);
        return true;
    }
}
})();
console.log(firstLoad(10));
console.log(firstLoad(10));
console.log(firstLoad(2));
</code></pre><h2 id="模拟缓存机制"><a href="#模拟缓存机制" class="headerlink" title="模拟缓存机制"></a>模拟缓存机制</h2><pre><code>var mult = function(){
var cache = {};
var calculate = function(){
    var a = 1;
    console.log(arguments);
    for(var i = 0,len = arguments.length;i&lt;len;i++){
        a = a*arguments[i];
    }
    return a;
}
return function(){
    var args = Array.prototype.join.call(arguments,&quot;,&quot;);//&quot;2,3&quot;
    if(args in cache){
        return cache[args];
    }
    cache[args] = calculate.apply(null,arguments);
    return cache[args];//6
}
}()
mult(2,3);
</code></pre><p>如果参数在缓存中存在，直接从缓存中取，如果不存在放入缓存中</p>
<h2 id="Ping图像数据上报"><a href="#Ping图像数据上报" class="headerlink" title="Ping图像数据上报"></a>Ping图像数据上报</h2><p>还记得跨域请求中的<img>标签实现的单向通信吗</p>
<pre><code>var    img = new Image();
    img.onload = img.onerror = function(){
        alert(&quot;Done!&quot;);
    } ;
    img.src = &quot;http://.....&quot;;
</code></pre><p>现在我们将其封装在一个函数中</p>
<pre><code>var report = function(src){
  var img = new Image();
  img.src = src;
}
report(&apos;http://xx.com/getUserInfo&apos;);
</code></pre><p>但是这样可能会导致数据上报不完全，因为当函数调用完以后，img变量就销毁，有可能现在还没有来得及发送HTTP请求哟~<br>因此我们把img变量用闭包封装起来</p>
<pre><code>var report = (function(){
var imgs = [];
return function(src){
    var    img = new Image();
    img.onload = img.onerror = function(){
        alert(&quot;Done!&quot;);
    } ;
    img.src = src;
}
})()
report(&quot;http://.....&quot;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/闭包/" data-id="cjnb805pp000454hotn7ubqqz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-绘图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/绘图/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/绘图/">Canvas和SVG的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>1.Canvas基于位图（像素）的：<br>放大后会出现像素格但颜色选择比较多，可以渲染比较真实感的图<br>2.canvas不可用事件处理器<br>3.一旦被绘制完成不会继续得到浏览器的关注<br>4.修改以后（如位置改变）会影响到整个场景，需要重新渲染<br>5.适合动态渲染，大数据量绘制如游戏场景渲染<br>6.能以JPG/PNG的形式存储<br>7.依赖于HTML，通过脚本绘制</p>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>1.基于矢量：不依赖分辨率<br>2.依赖于DOM,绘制的图形被视为对象,适用于交互,因此可以用JS控制元素，使用事件处理器<br>3.对象属性一旦发生变化，浏览器能自动重现图形<br>4.复杂度高，会减慢渲染速度<br>5.适用于大型渲染区域的程序如地图开发，静态高保真图形等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/绘图/" data-id="cjnb805pq000554ho128ewyet" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据存储" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/数据存储/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/数据存储/">浏览器存储技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h4 id="1-客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie"><a href="#1-客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie" class="headerlink" title="1.客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie"></a>1.客户端发送请求后服务器端发送带有set-cookie的相应，之后客户端再次发送请求时会发送cookie</h4><h4 id="2-document-cookie-name-value-expires-过期时间-path-页面路径-domain-域-secure-SSL链接时才能使用cookie的安全标志"><a href="#2-document-cookie-name-value-expires-过期时间-path-页面路径-domain-域-secure-SSL链接时才能使用cookie的安全标志" class="headerlink" title="2.document.cookie=name=value;expires=过期时间;path:页面路径;domain=域;secure(SSL链接时才能使用cookie的安全标志)"></a>2.document.cookie=name=value;expires=过期时间;path:页面路径;domain=域;secure(SSL链接时才能使用cookie的安全标志)</h4><h4 id="3-子cookie"><a href="#3-子cookie" class="headerlink" title="3.子cookie"></a>3.子cookie</h4><pre><code>document.cookie=data=name=Jake&amp;book=Professor;  
</code></pre><h4 id="4-有4k的存储空间-每条cookie有长度限制"><a href="#4-有4k的存储空间-每条cookie有长度限制" class="headerlink" title="4.有4k的存储空间,每条cookie有长度限制"></a>4.有4k的存储空间,每条cookie有长度限制</h4><h4 id="5-Js处理cookie"><a href="#5-Js处理cookie" class="headerlink" title="5.Js处理cookie"></a>5.Js处理cookie</h4><pre><code>下列为拥有子cookie的处理方法

var SubCookieUtil = {
get:function(name,subname){
    var subCookies = this.getAll(name);
    if(subCookies){
        return subCookies[subname];
    }else{
        return null;
    }
},
getAll:function(name){
    var cookieName = encodeURIComponent(name)+&quot;=&quot;;
    var cookieStart = document.cookie.indexOf(cookieName);
    var cookieEnd,
    subCookies,
    cookieValue = null,
    i,parts,result = {};
    if(cookieStart&gt;-1){
        cookieEnd = document.cookie.indexOf(&quot;;&quot;,cookieStart);
        if(cookieEnd == -1){
            cookieEnd = document.cookie.length;
        }

        cookieValue = document.cookie.substring(cookieStart+cookieName.length,cookieEnd);
        if(cookieValue.length &gt; 0){
            subCookies = cookieValue.split(&quot;&amp;&quot;);
            for(i = 0;i&lt;subCookies.length;i++){
                parts = subCookies[i].split(&quot;=&quot;);
                result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
            }
            return result;
        }
    }
    return null;
},
set:function(name,subName,value,expires,path,domin,secure){
    var subCookies = this.getAll
    (name)||{};
    subCookies[subName] = value;
    this.setAll(name,subCookies,expires,path,domin,secure);
},
setAll:function(name,subCookies,expires,path,domin,secure){
    var cookieText = encodeURIComponent(name)+&quot;=&quot;,
    subCookiesParts = new Array(),
    subName;
    for(subName in subCookies){
        if(subName.length&gt;0&amp;&amp;subCookies.hasOwnProperty(subName)){
            subCookiesParts.push(encodeURIComponent(subName)+&quot;=&quot;+encodeURIComponent(subCookies[subName]));
        }
    }
    if(subCookiesParts.length &gt; 0){
        cookieText +=subCookiesParts.join(&quot;&amp;&quot;);
        if(expires instanceof Date){
            cookieText += &quot;;expires=&quot;+expires.toGMTString();
        }
        if(path){
            cookieText += &quot;;path=&quot;+path;
        }
        if(domin){
            cookieText+=&quot;;domain=&quot;+domin;
        }
        if(secure){
            cookieText+=&quot;;secure&quot;;
        }
    }else{
            cookieText += &quot;;expires&quot;+(new Date(0)).toGMTString();
        }
        document.cookie = cookieText;
},
unset:function(name,subname,path,domain,secure){
    var subcookies = this.getAll(name);
    if(subcookies){
        delete subCookies[subname];
        this.setAll(name,subCookies,null,path,somain,secure);
    }
},
unsetAll:function(name,path,domain,secure){
    this.setAll(name,null,new Date(0),path,domain,secure);
}
};
SubCookieUtil.set(&quot;data&quot;,&quot;name&quot;,&quot;Nicole&quot;);
var getData = SubCookieUtil.getAll(&quot;data&quot;);
alert(SubCookieUtil.get(&quot;data&quot;,&quot;name&quot;));
</code></pre><h2 id="userData"><a href="#userData" class="headerlink" title="userData"></a>userData</h2><h4 id="iE处理用户数据的方式"><a href="#iE处理用户数据的方式" class="headerlink" title="iE处理用户数据的方式"></a>iE处理用户数据的方式</h4><pre><code>&lt;div style=&quot;behavior:url(#default#userData)&quot; id=&quot;dataStore&quot;&gt;&lt;/div&gt;
//js
var dataStore = document.getElementById(dataStore);
dataStore.setAttribute(&quot;name&quot;,&quot;Jake&quot;);
dataStore.setAttribute(&quot;book&quot;,&quot;professor&quot;);
//保存数据
dataStore.save(&quot;BookInfo&quot;)；
//设置数据空间
dataStore.load(&quot;BookInfo&quot;); 
//获取数据空间  
dataStore.getAttribute(&quot;name&quot;); 
//获取数据  
dataStore.removeAttribute(&quot;book&quot;);  
dataStore.save(&quot;BookInfo&quot;);
//删除后需再次提交更改  
</code></pre><h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><h4 id="storage类型"><a href="#storage类型" class="headerlink" title="storage类型"></a>storage类型</h4><p>1.被控制在客户端上，不会将数据返回给服务器<br>2.内存为5M或2.5M，可以大量存储数据</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>clear()删除全部<br>setItem(name,value)<br>getItem(name)<br>removeItem(name)<br>key(Index)获得在Index索引处的属性  </p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>length</p>
<h5 id="storage事件"><a href="#storage事件" class="headerlink" title="storage事件"></a>storage事件</h5><p>domain发生变化的存储空间的域<br>key发生变化的key<br>oldValue<br>newValue</p>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>会话存储，当浏览器关闭则自动清除不再保存</p>
<pre><code>sessionStorage.setItem(&quot;name&quot;,&quot;Nicoke&quot;);
sessionStorage.book = &quot;Professor&quot; //使用属性存储数据  var name = sessionStorage.getItem(&quot;name&quot;); 
var book = sessionStorage.book;
delete sessionStorage.name;  //在webkit中无效  
sessionStorage.remove(&quot;book&quot;);      
EventUtil.addHandler(document,&quot;storage&quot;,function(event){
    alert(event.domain);
});
</code></pre><h4 id="golbalStorage"><a href="#golbalStorage" class="headerlink" title="golbalStorage"></a>golbalStorage</h4><p>如果没有delete或remove或用户手动清除缓存，globalStorage将长期保存，一直保留在磁盘上</p>
<pre><code>golbalStorage[&quot;www.text.com&quot;].name = &quot;Nicole&quot;;
//[&quot;www.text.com&quot;]针对域名www.text.com的存储空间  
globalStorage[&quot;www.text.com&quot;].removeItem(&quot;name&quot;);
globalStorage[local.host].setItem();
//若不确定域名则使用local.host
</code></pre><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p> 取代globalStorage对象，不同的是localStorage不用实现定义域名，直接globalStorage[local.host] </p>
<pre><code>localStorage.setItem(&quot;name&quot;,&quot;Nickle&quot;);    
</code></pre><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>可以理解为用对象保存数据的数据库（MySql是表结构）  </p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><pre><code>var indexedDB = window.indexedDB||window.msIndexedDB||window.mozIndexedDB||window.webkitIndexedDB; 
//兼容性
var request,database;
var request = indexedDB.open(&quot;admin&quot;);
//admin为数据库名，如果不存在则会自动创建 ，返回请求对象，对象上可以添加两个事件error和success
request.onerror = function(event){
    alert(event.target.errorCode);
};
request.onsuccess = function(event){
    database = event.target.result;
    //返回数据内容
    if(database.version != &quot;1.0&quot; )
        request = database.setVersion(&quot;1.0&quot;);
        //设置版本号,返回请求对象
        request.onblock = function(){
            alert(&quot;请关闭其他页面再次尝试&quot;);
        }
        //并发问题：在想要更新数据库版本但另一个页面已打开数据库时
        request.onerror = function(event){
            alert(event.target.errorCode);
        };
        request.onsuccess = function(event){
            alert(database.name+database.version);
        }
    }else{
        alert(&quot;已经配置好版本号了&quot;)
    }
}
</code></pre><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>浏览器开了两个页面打开同一链接，当一个页面试图更新另一个还没有加载完的数据库时，调用setVersion()</p>
<pre><code>database.onversionChange = function(){
    database.close();
};
</code></pre><h4 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h4><pre><code>var user = {
    username:&quot;007&quot;,
    firstName : &quot;Jone&quot;,
    lastName:&quot;Bond&quot;,
    password:&quot;foo&quot;
};
var store = database.createObjectStore(&quot;users&quot;,{keyPath:&quot;userName&quot;});
//设置名为user的存储空间（在SQL即设名user的表）并设置主键username
//向存储空间添加数据
var i= 0 ,
requests = [];
len = user.length;
for(i&lt;len){
    request =  store.add[user[i++]];
    //add()添加新增数据和put方法添加更新数据，同样拥有两个事件处理程序  
    request.onerror = function(event){...}
    request.onsuccess = function(event){...}
    requests.push(request);
}
</code></pre><h4 id="创建事物-会返回事务级事件处理程序onerror和oncomplete"><a href="#创建事物-会返回事务级事件处理程序onerror和oncomplete" class="headerlink" title="创建事物(会返回事务级事件处理程序onerror和oncomplete)"></a>创建事物(会返回事务级事件处理程序onerror和oncomplete)</h4><pre><code>var transaction = database.transaction(&quot;users&quot;,IDBTransaction.READ_WRITE);
/*第一个参数为存储空间名,可指定多个存储空间，放在数组中，加载存储空间中的数据，通过事务访问  
第二个参数为访问模式：READ_ONLY  READ_WRITE VERSION_CHANGE
事件方法(会返回    新请求对象)：
objectStore()只加载特定的存储空间 
get()delete()接收对象键
add() put() clear()*/
var request = transaction.objectStore(&quot;users&quot;).get(&quot;007&quot;);
request.onerror ....  
transaction.oncomplete = function(event){...}
</code></pre><h4 id="游标查询"><a href="#游标查询" class="headerlink" title="游标查询"></a>游标查询</h4><pre><code>var store = transaction.objectStore(&quot;users&quot;);
var IDBKeyRange = window.IDBKeyRange||window.webkitKeyRange;
//键范围实例
var IDBCursor = window.IDBCursor||window.webkitIDBCursor;
//游标方向:
var nextNoDuplicate = IDBKeyRange.NEXT_NO_DUPLICATE;
//游标方向为从第一项到最后一项并跳过重复
//NEXT PREV PREV_NO_DUPLICATE
var range = IDBKeyRange.Bound(&quot;007&quot;,&quot;ace&quot;,true,false);
//此实例的方法：only(&quot;007&quot;)||upperBound()上界，游标从头开始到参数位置||lowerBound()下界，游标从参数位置到最后一个对象||Bound()
//布尔值值是否包含参数,false则跳过
request = store.openCursor(range,nextNoDuplicate);
//接收两个参数，IDBKeyRange的实例和IDBCursor的实例
//事务创建好后创建游标
request.onerror..
request.onsuccess = function(event){
    var cursor = event.target.result,
    value,updateRequest;
    /*此实例有几个属性：
        direction:IDBCursor.NEXT(0)(默认值下一个) ||IDBCursor.NEXT_NO_DUPLICATE(1)(下一个不重复的项）||IDBCursor.PREV_NO_DUPLICATE(2)（前一项）||IDBCursor.PREV_NO_DUPLICATE(前一个不重复的项)
        1.key  2.value  3.primaryKey:游标使用的键
    此实例有几个方法
        update()delete()continue()advance()
    */
    if(cursor){
        if(cursor.key == &quot;foo&quot;){
            value = cursor.value;
            value.password = &quot;magic&quot;;
            var updateRequest = cursor.update(value);//update也会创建一个新请求
            //delete同上一条，没有参数，删除当前项
        }
        console.log(cursor.key+&quot;:&quot;+JSON.stringify(event.value));
        cursor.continue();
    }
}
</code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>var index = store.createIndex(&quot;username&quot;,&quot;username&quot;,{unique:false});
//第一个参数：索引名 第二个参数：索引属性名 第三个参数：键是否唯一    
//store.Index(&quot;username&quot;)方法取得索引
var indexName = store.indexNames
//对象存储空间的对象indexName属性可访问到空间中的所有索引
var i = 0,len = indexNames.length;
while(i&lt;len){
    index = store.index(indexName[i++]);
    console.log(index.name+&quot;=&quot;+index.ketPath+index.unique);    
}
/*index方法：
    get()从索引中取对象 参数索引键 
    getKey()根据给定索引键取得主键
    deleteIndex(&quot;username&quot;) 
    openCursor() openKeyCursor()能在索引中打开游标并可以创建特殊的能返回每个记录主键的游标
属性：name索引名 keyPath创建索引的属性路径 onjectStore索引对象存储空间unique索引键是否唯一的布尔值*/
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/数据存储/" data-id="cjnb805pr000654ho9xjyarhc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this的指向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/this的指向/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/this的指向/">关于this指向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>this指的是调用当前方法（函数）的那个对象 </p>
<h2 id="一-无参数函数this的指向"><a href="#一-无参数函数this的指向" class="headerlink" title="一.无参数函数this的指向"></a>一.无参数函数this的指向</h2><p><code>function fn1(){  alert(this)  }</code>  </p>
<pre><code>fn1()   ===》window   
oBtn.onclick = fn1;   ===&gt; oBtn    
oBtn.onclick = function(){ this };   ===&gt; oBtn    
oBtn.onclick = function(){ fn() };   ===&gt; window
 oBtn.onclick = function(){ fn(this) };   ===&gt; oBtn
`&lt;button  onclick = &quot;alert(this  fn(1))&quot;&gt;&lt;/button&gt;`      this===&gt;button    fn1()里的this===&gt;window   
</code></pre><h2 id="二-、带参数函数this的指向"><a href="#二-、带参数函数this的指向" class="headerlink" title="二.、带参数函数this的指向"></a>二.、带参数函数this的指向</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre><code>fn1(this)  
function fn1(obj){  obj  }  obj===window    
</code></pre><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre><code>oDiv.onclick = function{
fn1(this) 
}  
function fn1(obj){
obj
}    obj ===》oDiv   
</code></pre><h2 id="三-当this指向window时用that存储"><a href="#三-当this指向window时用that存储" class="headerlink" title="三.当this指向window时用that存储"></a>三.当this指向window时用that存储</h2><pre><code>var that = null;
oBtn.onclick = function(){
that = this;
fn1();
}
fn1(){
that.style.background = &apos;yellow&apos;; 
}    
===》this指向oBtn
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/this的指向/" data-id="cjnb805qz000754hoqualqr18" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/16/vuex/">vuex</a>
          </li>
        
          <li>
            <a href="/2018/10/16/async-1/">async</a>
          </li>
        
          <li>
            <a href="/2018/10/16/vue.cil/">vue.cli</a>
          </li>
        
          <li>
            <a href="/2018/10/16/作用域/">作用域</a>
          </li>
        
          <li>
            <a href="/2018/10/16/闭包/">闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>