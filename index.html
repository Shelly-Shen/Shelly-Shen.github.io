<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shelly-Shen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="shelly&apos;s blog ———— share everything">
<meta property="og:type" content="website">
<meta property="og:title" content="Shelly-Shen">
<meta property="og:url" content="http://Shelly-Shen.github.io/index.html">
<meta property="og:site_name" content="Shelly-Shen">
<meta property="og:description" content="shelly&apos;s blog ———— share everything">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shelly-Shen">
<meta name="twitter:description" content="shelly&apos;s blog ———— share everything">
  
    <link rel="alternate" href="/atom.xml" title="Shelly-Shen" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shelly-Shen</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Shelly-Shen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue-cil" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/vue-cil/" class="article-date">
  <time datetime="2018-10-16T04:26:13.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/vue-cil/">vue-cil</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code>npm install --global vue-cli
切换到项目目录
cd vuetest

安装一来模块
npm install
运行
npm run dev
打包
npm run build
</code></pre><p>main.js入口文件</p>
<pre><code>import Vue from &apos;vue&apos;
import todoList from &apos;./todoList.vue&apos;
</code></pre><p>new Vue({<br>    el：‘#app’,<br>    component:{todoList}<br>    template:’<todolist>‘<br>})</todolist></p>
<p>app.vue改为todoList 组件</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
    &lt;div&gt;
        &lt;input class=&quot;item&quot; v-model:&quot;inputValue&quot;&gt;
        &lt;button @click = &quot;handleSubmit&quot;&gt;提交&lt;/button&gt;
    &lt;/div&gt;
    &lt;ul&gt;
    &lt;todoItem v-for=&quot;{item,index } of list&quot; :key=&quot;index&quot; :content=&quot;item&quot; :index=&quot;index&quot; @delete = “myhandeldelete” &gt;&lt;/todoItem&gt;      //经过下面的组件声明方可使用 ，定义content目的父组件传值给子组件,监听delete事件触发此文件定义的myhandelDelete事件
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;//template中只能有一个子元素
&lt;script&gt;
import todoItem from &apos;./component/todoItem&apos;  //其为局部组件
export default{
    components:{
        &apos;todoItem&apos;:todoItem     //局部组件进行声明
    }
    data:function(){         //data从对象变成函数,其返回值对应的数据
        return {
        inputValue:&apos;&apos;,
        list:[]
        }
    },
    methods:{
        handelSubmit(){
            this.list.push(this.inputValue)  //this指向实例，vue底层将this.$data.list处理缩写成this.list
            this.inputvalue=&quot;&quot;
        },
        myhandelDelete(index){
            this.List.splice(index,1)
        }
    }    
}
&lt;/script&gt;
&lt;style&gt;&lt;/style&gt;
</code></pre><p>hellworld.vue==&gt;todoItem.vue</p>
<pre><code>&lt;template&gt;
    &lt;li class=&quot;item&quot; @click=&quot;handleDelete&quot;&gt;{{content}}&lt;/li&gt;
&lt;/template&gt;
&lt;script&gt;
    export default{
        props:[&apos;content&apos;,&apos;index&apos;], //声明对content的使用即接收名为content的数据
        methods:{
            handleDelete(){
                this.$emit(&apos;delete&apos;,this.index)//子组件向父组件通信,使用$emit向外触发事件delete,将this.index待会给父组件
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;    // scoped指组件作用域（局部样式）,组件外部的样式使用里面的内容没有作用
    .item{
        color
    }    
&lt;/style&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/vue-cil/" data-id="cjnbfi9yz0002zchovrw4yegb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vuex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/vuex/" class="article-date">
  <time datetime="2018-10-16T03:55:33.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/vuex/">vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>new Vue({
//state
    data(){
        return{
            count:0
        }
    },
//view
    template:`&lt;div&gt;{{count}}&lt;/div&gt;`,
//actions
    methods:{
        increment(){
            this.count++
        }
    }
})
</code></pre><p>多个视图（<code>view</code>）需要依赖同一状态或不同视图更改同一状态时使用vuex,将组件的共享状态抽出，以一个全局单例模式管理，使任何组件都可获取状态和触发它</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>改变<code>store</code>唯一的途径就是提交（<code>store.commit(&#39;mutation定义的方法&#39;)</code>）<code>mutation</code>  </p>
<h3 id="组件调用store"><a href="#组件调用store" class="headerlink" title="组件调用store:"></a>组件调用store:</h3><p>由于store是响应式的，在组件中调用Store中的状态只需在计算属性中返回</p>
<pre><code>const Counter = {
    template:`&lt;div&gt;count&lt;/div&gt;`,
    computed:{
        count(){
            return store.state.count
        }
    }
}
</code></pre><p>为防止每个组件频繁导入state，将根组件“注入”到每个子组件中（需要调用Vue.use(Vuex)）子组件在computed中通过<code>this.$store</code>访问</p>
<pre><code>const app = new Vue({
    el:&quot;#app&quot;,
    store,
    //调用store项，可以把Store实例注入所有的子组件
    components:{Counter},
    template:`
        &lt;div class=&quot;app&quot;&gt;
            &lt;counter&gt;&lt;/counter&gt;
        &lt;/div&gt;

    `
})
</code></pre><p>当一个组件需要获取多个状态</p>
<pre><code>import {mapState} from &apos;vuex&apos;
export default{
    computed:mapState({
        //count函数返回状态中的属性
        count:state=&gt;state.count
        //将字符串参数&apos;count&apos;等同于‘state=&gt;state.count’
        countAlias:&apos;count&apos;
        countPlusLocalState(state){
         // 为了能够使用 `this` 获取局部状态，必须使用常规函数
            return state.count+this.localCount
        }
    })    
} 
</code></pre><p>..</p>
<pre><code>computed:mapState([&apos;count&apos;])
//映射this.count为store.state.count
</code></pre><p>将<code>mapstate</code>与局部计算属性混合使用对象展开运算符</p>
<h3 id="组件触发变化"><a href="#组件触发变化" class="headerlink" title="组件触发变化:"></a>组件触发变化:</h3><p>在methods中提交mutation</p>
<h2 id="getters（store的计算属性）"><a href="#getters（store的计算属性）" class="headerlink" title="getters（store的计算属性）"></a>getters（store的计算属性）</h2><p>依赖发生变化才会重新计算</p>
<pre><code>const store = new Vuex.Store({
    state:{
        todos:[
        {id:1,text:&apos;...&apos;,done:true},
        {id:1,text:&apos;...&apos;,done:false}
        ]
    },
    getters:{
        doneTodos:state=&gt;{
            return state.todos.filter(todo=&gt;todo.done)
        },
        doneTodosCount:(state,getters)=&gt;{
                return getters.doneTodos.length
            }
        //getter接收其他getter作为第二参数
        },
        getTodoById:(state)=&gt;(id)=&gt;{
            return state.todos.find(todo=&gt;todo)
        }
        //给getter中的方法传参
    }
})
</code></pre><h4 id="以属性的形式访问值"><a href="#以属性的形式访问值" class="headerlink" title="以属性的形式访问值"></a>以属性的形式访问值</h4><pre><code>store.getters.doneTodos // -&gt; [{ id: 1, text: &apos;...&apos;, done: true }]
store.getters.doneTodosCount // -&gt; 1
store.getters.getTodoById(2) // -&gt; { id: 2, text: &apos;...&apos;, done: false }
</code></pre><p>在组件中使用它</p>
<pre><code>computed:{
    doneTodisCount(){
        return this.$store.getter.doneTodoCount
    }
}
</code></pre><h3 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h3><p>将getter映射到局部计算属性：</p>
<pre><code>import {mapGetters} from &apos;vuex&apos;
export default{
    computed:{
        ...mapGetters([
                doneCount:&apos;doneTodosCount&apos;,
                &apos;antherGetter&apos;//默认用原名
        ])
    }
}    
</code></pre><h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><p>必须是同步函数<br>任何在回调函数中进行的状态的改变都是不可追踪的</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,n){
            state.count += n ;
        }
    }    
})
</code></pre><p>不能直接调用mutation handler，这个选项类似事件注册：“当触发一个type(类型为increment)的mutation时，调用函数”，因此使用store.commit传入相应的type</p>
<pre><code>store.commit(&apos;increment&apos;,22)
</code></pre><h3 id="payload将n换成payload对象即可"><a href="#payload将n换成payload对象即可" class="headerlink" title="payload将n换成payload对象即可"></a>payload将n换成payload对象即可</h3><p>传入对象</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,payload){
            state.count += payload.amount ;
        }
    }    
})
store.commit(&apos;increment&apos;,{
    amount:10
})    
---------------------------------
//或者
//提交mutation的另一种方式（对象风格）
    store.commit({
        type:&apos;increment&apos;,
        amount:10
    })
</code></pre><h3 id="store的state添加新属性"><a href="#store的state添加新属性" class="headerlink" title="store的state添加新属性"></a>store的state添加新属性</h3><pre><code>Vue.set(obj,&apos;newProp&apos;,123)
-----------或者
state.obj = {...state.obj,newProp:123}
</code></pre><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>使用<code>mapMutations</code>将组件中的methods映射为store.commit调用（需要在根节点注入store）</p>
<pre><code>import {mapMutations} from &apos;vuex&apos;
export default{
    methods:{
        ...mapMutations({
            ‘increment’,//将`this.increment`映射为`this.$store.commit(increment)`  
            &apos;incrementBy&apos; 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`
        }),
        ...mapMutations({
            add:&apos;increment&apos; //将this.add()映射为`this.$store.commit(&apos;increment&apos;)`
        })
    }
}
</code></pre><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>1.提交的是mutation2.可以进行异步操作</p>
<pre><code>const store = new Vuex.store({
    state:{
        count:0
    },
    mutation:{
        increment(state){
            state.count++;
        }
    },
    action:{
        incrementAsync({commit}){ //参数解构 ==》context.commit==&gt;context类似store实例
            setTimeout(()=&gt;{
                commit(&apos;increment&apos;)
            },1000)  //进行异步操作
        }
    }
})
</code></pre><h3 id="分发方式通过store-dispatch触发（类似于store-commit-）"><a href="#分发方式通过store-dispatch触发（类似于store-commit-）" class="headerlink" title="分发方式通过store.dispatch触发（类似于store.commit()）"></a>分发方式通过store.dispatch触发（类似于store.commit()）</h3><pre><code>store.dispatch(&apos;incrementAsync&apos;,{amount:10})
//同样支持以对象形式分发
store.dispatch({
    type:&apos;incrementAsync&apos;,
    amount:10
})
</code></pre><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><pre><code>import {mapActions} from &apos;vuex&apos;
export default{
    methods:{
        ...mapActions([
            &apos;increment&apos;,//将`this.increment()`映射为`this.$store.dispatch(&apos;increment&apos;)`
        ]),
        ...mapActions({
            add:&apos;increment&apos;//将`this.add()`映射为`this.$store.dispatch(increment)`
        })
    }
}
</code></pre><h3 id="组合Action"><a href="#组合Action" class="headerlink" title="组合Action"></a>组合Action</h3><p>store.dispatch可以处理被触发的action的处理函数返回promise并且store.dispatch仍旧返回promise</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    }
}
</code></pre><hr>
<pre><code>store.dispatch(&apos;actionA&apos;).then(()=&gt;{...})
</code></pre><p>在另一个action中调用action</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    },
    actionB({dispatch,commit}){
        return dispatch(&apos;actionA&apos;).then(()=&gt;{
            commit(&apos;someOtherMutation&apos;)
        })
    }
}
</code></pre><p>使用asych/await</p>
<pre><code>actions:{
    async actionA({commit}){
        commit(&apos;gotAta&apos;,await getDate())
    },
    async actionA({dispatch,commit}){
        await dispatch(&apos;actionA&apos;)
        commit(&apos;gotOtherAta&apos;,await getOtherDate())
    }
}
</code></pre><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>将store分割成模块，每个模块拥有自己的<code>state</code>,<code>mutation</code>,<code>action</code>,<code>getter</code>,甚至嵌套子模块</p>
<pre><code>const moduleA = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const moduleB = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const store = new Vuex.Store({
    models:{
        a:moduleA,
        b:moduleB
    }
})
</code></pre><h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>mutation和getters接收的第一个参数（state）是局部的<br>对于action和getters通过第三个参数暴露出来：({state,commit,<code>rootState</code>|<code>rootGetter</code>})<br>分发时将{root:true}作第三参数传给dispatch得到全局</p>
<h3 id="命名空间namespaces-true"><a href="#命名空间namespaces-true" class="headerlink" title="命名空间namespaces:true"></a>命名空间namespaces:true</h3><pre><code>modules: {
  foo: {  //命名空间
    namespaced: true,

    getters: {
      // 在这个模块的 getter 中，`getters` 被局部化了
      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter // -&gt; &apos;foo/someOtherGetter&apos;
        rootGetters.someOtherGetter // -&gt; &apos;someOtherGetter&apos;
      },
      someOtherGetter: state =&gt; { ... }
    },

    actions: {
      // 在这个模块中， dispatch 和 commit 也被局部化了
      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter // -&gt; &apos;foo/someGetter&apos;
        rootGetters.someGetter // -&gt; &apos;someGetter&apos;

        dispatch(&apos;someOtherAction&apos;) // -&gt; &apos;foo/someOtherAction&apos;
        dispatch(&apos;someOtherAction&apos;, null, { root: true }) // -&gt; &apos;someOtherAction&apos;

        commit(&apos;someMutation&apos;) // -&gt; &apos;foo/someMutation&apos;
        commit(&apos;someMutation&apos;, null, { root: true }) // -&gt; &apos;someMutation&apos;
      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}
</code></pre><h3 id="在命名空间模块中注册全局action"><a href="#在命名空间模块中注册全局action" class="headerlink" title="在命名空间模块中注册全局action"></a>在命名空间模块中注册全局action</h3><p>添加root:true并将这个action放在handler中</p>
<pre><code>{
    actions:{
        someOtherAcrion({dispatch}){
            dispatch(&apos;someAction&apos;)    
        }
    },
    modules:{
        foo:{
            namespaced:true,
            actions:{
                someAction:{
                    `root:true`,
                    handler(namespacedContext,payload){...}
                }
            }
        }
    }
}
</code></pre><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>由于命名空间的存在mapState,maoGetters,mapActions,mapMutations绑定命名空间起来比较繁琐</p>
<pre><code>computed:{
    ...mapState({
        a:state =&gt;state.some.nested.module.a
    })
},    
methods:{
    ...mapActions([
        &apos;some/nested/module/foo&apos;
    ])
}
</code></pre><p>可以简化为</p>
<pre><code>computed: {
  ...mapState(&apos;some/nested/module&apos;, {   //空间名称字符串作为第一个参数传递给函数
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions(&apos;some/nested/module&apos;, [
    &apos;foo&apos;,
    &apos;bar&apos;
  ])
}
</code></pre><h4 id="createNamespacedHelpers命名空间辅助函数。它返回一个对象"><a href="#createNamespacedHelpers命名空间辅助函数。它返回一个对象" class="headerlink" title="createNamespacedHelpers命名空间辅助函数。它返回一个对象"></a>createNamespacedHelpers命名空间辅助函数。它返回一个对象</h4><pre><code>import { createNamespacedHelpers } from &apos;vuex&apos;

***const { mapState, mapActions } = createNamespacedHelpers(&apos;some/nested/module&apos;)

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state =&gt; state.a,
      b: state =&gt; state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      &apos;foo&apos;,
      &apos;bar&apos;
    ])
  }
}
</code></pre><h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><pre><code>store.registerModule(&apos;myMoudule&apos;,{
    ...
})//注册模块`myModule`
store.registerModule([&apos;nested&apos;,&apos;myMoudel&apos;]),{
    ...
}//注册嵌套模`nested/myModule`
</code></pre><p>通过store.state.myMoudel和store.state.nested.myMoudel访问</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/vuex/" data-id="cjnbfi9yx0001zchoelfjdwoq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-async-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/async-1/" class="article-date">
  <time datetime="2018-10-16T03:46:00.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/async-1/">async</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><pre><code>const asyncReadFile = async function () {
  const f1 = await readFile(&apos;/etc/fstab&apos;);
  const f2 = await readFile(&apos;/etc/shells&apos;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre><ul>
<li>async表示函数里有异步操作，asyn，await后的函数会返回一个Promise 对象，,await命令就是内部then命令的语法糖  </li>
<li>await会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
<li><p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<pre><code>async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
}

getStockPriceByName(&apos;goog&apos;).then(function (result) {
  console.log(result);
});
</code></pre></li>
<li><p>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><pre><code>async function f() {
  try {
    await new Promise(function (resolve, reject) {
      throw new Error(&apos;出错了&apos;);
    });
  } catch(e) {
  }
  return await(&apos;hello world&apos;);
}

//另一种写法
async function myFunction() {
  await somethingThatReturnsAPromise()
  .catch(function (err) {
    console.log(err);
  });
}
</code></pre><h2 id="同时触发"><a href="#同时触发" class="headerlink" title="同时触发"></a>同时触发</h2><p>  let [foo, bar] = await Promise.all([getFoo(), getBar()]);</p>
<p>  // 写法二<br>  let fooPromise = getFoo();<br>  let barPromise = getBar();<br>  let foo = await fooPromise;<br>  let bar = await barPromise;</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/async-1/" data-id="cjnbfi9yq0000zcho4e7z7ay0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/闭包/" class="article-date">
  <time datetime="2018-10-16T03:10:42.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数作为返回值被返回"><a href="#函数作为返回值被返回" class="headerlink" title="函数作为返回值被返回"></a>函数作为返回值被返回</h2><pre><code>function F(){
    var a = 1;
    function foo(){
        return a;
    }
    return foo;
}        
console.log(F()());   
</code></pre><h2 id="函数被赋给一个变量"><a href="#函数被赋给一个变量" class="headerlink" title="函数被赋给一个变量"></a>函数被赋给一个变量</h2><pre><code>var ret;
function F(){
    var a = 1;
    function foo(){
        return a;
    }
    ret = foo;
}
F()          
console.log(ret());
</code></pre><p>作用：<br>在在作用域以外的地方（全局作用域)中执行函数，但函数有其特定的作用域</p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><pre><code>function inner(fn){
    console.log(fn());    
}
(function(){
var a = 1;
function foo(){
    return a;
}
inner(foo)
 })()
</code></pre><p>在立即执行函数中被声明（作用域）,在inner函数中被调用    </p>
<h2 id="循环问题"><a href="#循环问题" class="headerlink" title="循环问题"></a>循环问题</h2><pre><code>function foo(){
    var arr = [];
    for(var i = 0;i&lt;2;i++){
        arr[i] = function(){
            return i;
        }
    }
    return arr;
}
var bar = foo();
console.log(bar[0]());
</code></pre><p>:<img src="root.png" alt=""></p>
<h3 id="使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值"><a href="#使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值" class="headerlink" title="使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值"></a>使用立即执行函数，创建多个执行环境保存循环时各个状态的索引值</h3><pre><code>function foo(){
    var arr =  [] ;
    for(var i = 0;i&lt;2;i++){
        arr[i] = (function(j){
            return function test(){
                return j;
            }
        })(i)
    }
return arr;
}
var bar = foo();
console.log(bar[0]());
</code></pre><p>:<img src="roott.png" alt=""></p>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>循环中的变量使用let</p>
<h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter||setter"></a>getter||setter</h2><p>通过setValue和getValue将要操作的变量保存在函数内部，防止暴露在外部</p>
<pre><code>var getValule,setValue
(function(){
var a = 0;
getValue = function(){
    return a;
}
setValue = function(i){
    if(typeof i === &apos;number&apos;){
        a = i;
    }
}
})()
console.log(getValue());
setValue(1);
console.log(getValue());
</code></pre><h2 id="使用闭包实现迭代器"><a href="#使用闭包实现迭代器" class="headerlink" title="使用闭包实现迭代器"></a>使用闭包实现迭代器</h2><pre><code>function F(arr){
    var i = 0;
    return function(){
        return arr[i++]
    } 
}
var next = F([1,2,3]);
console.log(next());//1
console.log(next());//2
</code></pre><h2 id="使用闭包区分首次"><a href="#使用闭包区分首次" class="headerlink" title="使用闭包区分首次"></a>使用闭包区分首次</h2><pre><code>var firstLoad = (function(id){
var list = [];
return function(id){
    if(list.indexOf(id) &gt;= 0){
        return false;
    }else{
        list.push(id);
        return true;
    }
}
})();
console.log(firstLoad(10));
console.log(firstLoad(10));
console.log(firstLoad(2));
</code></pre><h2 id="模拟缓存机制"><a href="#模拟缓存机制" class="headerlink" title="模拟缓存机制"></a>模拟缓存机制</h2><pre><code>var mult = function(){
var cache = {};
var calculate = function(){
    var a = 1;
    console.log(arguments);
    for(var i = 0,len = arguments.length;i&lt;len;i++){
        a = a*arguments[i];
    }
    return a;
}
return function(){
    var args = Array.prototype.join.call(arguments,&quot;,&quot;);//&quot;2,3&quot;
    if(args in cache){
        return cache[args];
    }
    cache[args] = calculate.apply(null,arguments);
    return cache[args];//6
}
}()
mult(2,3);
</code></pre><p>如果参数在缓存中存在，直接从缓存中取，如果不存在放入缓存中</p>
<h2 id="Ping图像数据上报"><a href="#Ping图像数据上报" class="headerlink" title="Ping图像数据上报"></a>Ping图像数据上报</h2><p>还记得跨域请求中的<img>标签实现的单向通信吗</p>
<pre><code>var    img = new Image();
    img.onload = img.onerror = function(){
        alert(&quot;Done!&quot;);
    } ;
    img.src = &quot;http://.....&quot;;
</code></pre><p>现在我们将其封装在一个函数中</p>
<pre><code>var report = function(src){
  var img = new Image();
  img.src = src;
}
report(&apos;http://xx.com/getUserInfo&apos;);
</code></pre><p>但是这样可能会导致数据上报不完全，因为当函数调用完以后，img变量就销毁，有可能现在还没有来得及发送HTTP请求哟~<br>因此我们把img变量用闭包封装起来</p>
<pre><code>var report = (function(){
var imgs = [];
return function(src){
    var    img = new Image();
    img.onload = img.onerror = function(){
        alert(&quot;Done!&quot;);
    } ;
    img.src = src;
}
})()
report(&quot;http://.....&quot;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/闭包/" data-id="cjnbfi9z10003zchog1wi9ys9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/16/vue-cil/">vue-cil</a>
          </li>
        
          <li>
            <a href="/2018/10/16/vuex/">vuex</a>
          </li>
        
          <li>
            <a href="/2018/10/16/async-1/">async</a>
          </li>
        
          <li>
            <a href="/2018/10/16/闭包/">闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>