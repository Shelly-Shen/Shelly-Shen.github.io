<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>vuex | Shelly-Shen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="new Vue({ //state     data(){         return{             count:0         }     }, //view     template:`&amp;lt;div&amp;gt;{{count}}&amp;lt;/div&amp;gt;`, //actions     methods:{         increment(){             this">
<meta property="og:type" content="article">
<meta property="og:title" content="vuex">
<meta property="og:url" content="http://Shelly-Shen.github.io/2018/10/16/vuex/index.html">
<meta property="og:site_name" content="Shelly-Shen">
<meta property="og:description" content="new Vue({ //state     data(){         return{             count:0         }     }, //view     template:`&amp;lt;div&amp;gt;{{count}}&amp;lt;/div&amp;gt;`, //actions     methods:{         increment(){             this">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-16T03:56:02.978Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vuex">
<meta name="twitter:description" content="new Vue({ //state     data(){         return{             count:0         }     }, //view     template:`&amp;lt;div&amp;gt;{{count}}&amp;lt;/div&amp;gt;`, //actions     methods:{         increment(){             this">
  
    <link rel="alternate" href="/atom.xml" title="Shelly-Shen" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shelly-Shen</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Shelly-Shen.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-vuex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/vuex/" class="article-date">
  <time datetime="2018-10-16T03:55:33.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      vuex
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>new Vue({
//state
    data(){
        return{
            count:0
        }
    },
//view
    template:`&lt;div&gt;{{count}}&lt;/div&gt;`,
//actions
    methods:{
        increment(){
            this.count++
        }
    }
})
</code></pre><p>多个视图（<code>view</code>）需要依赖同一状态或不同视图更改同一状态时使用vuex,将组件的共享状态抽出，以一个全局单例模式管理，使任何组件都可获取状态和触发它</p>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>改变<code>store</code>唯一的途径就是提交（<code>store.commit(&#39;mutation定义的方法&#39;)</code>）<code>mutation</code>  </p>
<h3 id="组件调用store"><a href="#组件调用store" class="headerlink" title="组件调用store:"></a>组件调用store:</h3><p>由于store是响应式的，在组件中调用Store中的状态只需在计算属性中返回</p>
<pre><code>const Counter = {
    template:`&lt;div&gt;count&lt;/div&gt;`,
    computed:{
        count(){
            return store.state.count
        }
    }
}
</code></pre><p>为防止每个组件频繁导入state，将根组件“注入”到每个子组件中（需要调用Vue.use(Vuex)）子组件在computed中通过<code>this.$store</code>访问</p>
<pre><code>const app = new Vue({
    el:&quot;#app&quot;,
    store,
    //调用store项，可以把Store实例注入所有的子组件
    components:{Counter},
    template:`
        &lt;div class=&quot;app&quot;&gt;
            &lt;counter&gt;&lt;/counter&gt;
        &lt;/div&gt;

    `
})
</code></pre><p>当一个组件需要获取多个状态</p>
<pre><code>import {mapState} from &apos;vuex&apos;
export default{
    computed:mapState({
        //count函数返回状态中的属性
        count:state=&gt;state.count
        //将字符串参数&apos;count&apos;等同于‘state=&gt;state.count’
        countAlias:&apos;count&apos;
        countPlusLocalState(state){
         // 为了能够使用 `this` 获取局部状态，必须使用常规函数
            return state.count+this.localCount
        }
    })    
} 
</code></pre><p>..</p>
<pre><code>computed:mapState([&apos;count&apos;])
//映射this.count为store.state.count
</code></pre><p>将<code>mapstate</code>与局部计算属性混合使用对象展开运算符</p>
<h3 id="组件触发变化"><a href="#组件触发变化" class="headerlink" title="组件触发变化:"></a>组件触发变化:</h3><p>在methods中提交mutation</p>
<h2 id="getters（store的计算属性）"><a href="#getters（store的计算属性）" class="headerlink" title="getters（store的计算属性）"></a>getters（store的计算属性）</h2><p>依赖发生变化才会重新计算</p>
<pre><code>const store = new Vuex.Store({
    state:{
        todos:[
        {id:1,text:&apos;...&apos;,done:true},
        {id:1,text:&apos;...&apos;,done:false}
        ]
    },
    getters:{
        doneTodos:state=&gt;{
            return state.todos.filter(todo=&gt;todo.done)
        },
        doneTodosCount:(state,getters)=&gt;{
                return getters.doneTodos.length
            }
        //getter接收其他getter作为第二参数
        },
        getTodoById:(state)=&gt;(id)=&gt;{
            return state.todos.find(todo=&gt;todo)
        }
        //给getter中的方法传参
    }
})
</code></pre><h4 id="以属性的形式访问值"><a href="#以属性的形式访问值" class="headerlink" title="以属性的形式访问值"></a>以属性的形式访问值</h4><pre><code>store.getters.doneTodos // -&gt; [{ id: 1, text: &apos;...&apos;, done: true }]
store.getters.doneTodosCount // -&gt; 1
store.getters.getTodoById(2) // -&gt; { id: 2, text: &apos;...&apos;, done: false }
</code></pre><p>在组件中使用它</p>
<pre><code>computed:{
    doneTodisCount(){
        return this.$store.getter.doneTodoCount
    }
}
</code></pre><h3 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h3><p>将getter映射到局部计算属性：</p>
<pre><code>import {mapGetters} from &apos;vuex&apos;
export default{
    computed:{
        ...mapGetters([
                doneCount:&apos;doneTodosCount&apos;,
                &apos;antherGetter&apos;//默认用原名
        ])
    }
}    
</code></pre><h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><p>必须是同步函数<br>任何在回调函数中进行的状态的改变都是不可追踪的</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,n){
            state.count += n ;
        }
    }    
})
</code></pre><p>不能直接调用mutation handler，这个选项类似事件注册：“当触发一个type(类型为increment)的mutation时，调用函数”，因此使用store.commit传入相应的type</p>
<pre><code>store.commit(&apos;increment&apos;,22)
</code></pre><h3 id="payload将n换成payload对象即可"><a href="#payload将n换成payload对象即可" class="headerlink" title="payload将n换成payload对象即可"></a>payload将n换成payload对象即可</h3><p>传入对象</p>
<pre><code>const store = new Vuex.store({
    state:{
        count :1
    },
    mutation:{
        increment(state,payload){
            state.count += payload.amount ;
        }
    }    
})
store.commit(&apos;increment&apos;,{
    amount:10
})    
---------------------------------
//或者
//提交mutation的另一种方式（对象风格）
    store.commit({
        type:&apos;increment&apos;,
        amount:10
    })
</code></pre><h3 id="store的state添加新属性"><a href="#store的state添加新属性" class="headerlink" title="store的state添加新属性"></a>store的state添加新属性</h3><pre><code>Vue.set(obj,&apos;newProp&apos;,123)
-----------或者
state.obj = {...state.obj,newProp:123}
</code></pre><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>使用<code>mapMutations</code>将组件中的methods映射为store.commit调用（需要在根节点注入store）</p>
<pre><code>import {mapMutations} from &apos;vuex&apos;
export default{
    methods:{
        ...mapMutations({
            ‘increment’,//将`this.increment`映射为`this.$store.commit(increment)`  
            &apos;incrementBy&apos; 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`
        }),
        ...mapMutations({
            add:&apos;increment&apos; //将this.add()映射为`this.$store.commit(&apos;increment&apos;)`
        })
    }
}
</code></pre><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>1.提交的是mutation2.可以进行异步操作</p>
<pre><code>const store = new Vuex.store({
    state:{
        count:0
    },
    mutation:{
        increment(state){
            state.count++;
        }
    },
    action:{
        incrementAsync({commit}){ //参数解构 ==》context.commit==&gt;context类似store实例
            setTimeout(()=&gt;{
                commit(&apos;increment&apos;)
            },1000)  //进行异步操作
        }
    }
})
</code></pre><h3 id="分发方式通过store-dispatch触发（类似于store-commit-）"><a href="#分发方式通过store-dispatch触发（类似于store-commit-）" class="headerlink" title="分发方式通过store.dispatch触发（类似于store.commit()）"></a>分发方式通过store.dispatch触发（类似于store.commit()）</h3><pre><code>store.dispatch(&apos;incrementAsync&apos;,{amount:10})
//同样支持以对象形式分发
store.dispatch({
    type:&apos;incrementAsync&apos;,
    amount:10
})
</code></pre><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><pre><code>import {mapActions} from &apos;vuex&apos;
export default{
    methods:{
        ...mapActions([
            &apos;increment&apos;,//将`this.increment()`映射为`this.$store.dispatch(&apos;increment&apos;)`
        ]),
        ...mapActions({
            add:&apos;increment&apos;//将`this.add()`映射为`this.$store.dispatch(increment)`
        })
    }
}
</code></pre><h3 id="组合Action"><a href="#组合Action" class="headerlink" title="组合Action"></a>组合Action</h3><p>store.dispatch可以处理被触发的action的处理函数返回promise并且store.dispatch仍旧返回promise</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    }
}
</code></pre><hr>
<pre><code>store.dispatch(&apos;actionA&apos;).then(()=&gt;{...})
</code></pre><p>在另一个action中调用action</p>
<pre><code>actions:{
    actionsA({commit}){
        return new Promise((resolve,reject)=&gt;{
            setTimeout(()=&gt;{
                commit(&apos;someMutation&apos;)
                resolve()
            },1000)    
        })
    },
    actionB({dispatch,commit}){
        return dispatch(&apos;actionA&apos;).then(()=&gt;{
            commit(&apos;someOtherMutation&apos;)
        })
    }
}
</code></pre><p>使用asych/await</p>
<pre><code>actions:{
    async actionA({commit}){
        commit(&apos;gotAta&apos;,await getDate())
    },
    async actionA({dispatch,commit}){
        await dispatch(&apos;actionA&apos;)
        commit(&apos;gotOtherAta&apos;,await getOtherDate())
    }
}
</code></pre><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>将store分割成模块，每个模块拥有自己的<code>state</code>,<code>mutation</code>,<code>action</code>,<code>getter</code>,甚至嵌套子模块</p>
<pre><code>const moduleA = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const moduleB = {
    state:{..}
    mutations:{..}
    actions:{..}
    getters:{...}
}
const store = new Vuex.Store({
    models:{
        a:moduleA,
        b:moduleB
    }
})
</code></pre><h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>mutation和getters接收的第一个参数（state）是局部的<br>对于action和getters通过第三个参数暴露出来：({state,commit,<code>rootState</code>|<code>rootGetter</code>})<br>分发时将{root:true}作第三参数传给dispatch得到全局</p>
<h3 id="命名空间namespaces-true"><a href="#命名空间namespaces-true" class="headerlink" title="命名空间namespaces:true"></a>命名空间namespaces:true</h3><pre><code>modules: {
  foo: {  //命名空间
    namespaced: true,

    getters: {
      // 在这个模块的 getter 中，`getters` 被局部化了
      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter // -&gt; &apos;foo/someOtherGetter&apos;
        rootGetters.someOtherGetter // -&gt; &apos;someOtherGetter&apos;
      },
      someOtherGetter: state =&gt; { ... }
    },

    actions: {
      // 在这个模块中， dispatch 和 commit 也被局部化了
      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter // -&gt; &apos;foo/someGetter&apos;
        rootGetters.someGetter // -&gt; &apos;someGetter&apos;

        dispatch(&apos;someOtherAction&apos;) // -&gt; &apos;foo/someOtherAction&apos;
        dispatch(&apos;someOtherAction&apos;, null, { root: true }) // -&gt; &apos;someOtherAction&apos;

        commit(&apos;someMutation&apos;) // -&gt; &apos;foo/someMutation&apos;
        commit(&apos;someMutation&apos;, null, { root: true }) // -&gt; &apos;someMutation&apos;
      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}
</code></pre><h3 id="在命名空间模块中注册全局action"><a href="#在命名空间模块中注册全局action" class="headerlink" title="在命名空间模块中注册全局action"></a>在命名空间模块中注册全局action</h3><p>添加root:true并将这个action放在handler中</p>
<pre><code>{
    actions:{
        someOtherAcrion({dispatch}){
            dispatch(&apos;someAction&apos;)    
        }
    },
    modules:{
        foo:{
            namespaced:true,
            actions:{
                someAction:{
                    `root:true`,
                    handler(namespacedContext,payload){...}
                }
            }
        }
    }
}
</code></pre><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>由于命名空间的存在mapState,maoGetters,mapActions,mapMutations绑定命名空间起来比较繁琐</p>
<pre><code>computed:{
    ...mapState({
        a:state =&gt;state.some.nested.module.a
    })
},    
methods:{
    ...mapActions([
        &apos;some/nested/module/foo&apos;
    ])
}
</code></pre><p>可以简化为</p>
<pre><code>computed: {
  ...mapState(&apos;some/nested/module&apos;, {   //空间名称字符串作为第一个参数传递给函数
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions(&apos;some/nested/module&apos;, [
    &apos;foo&apos;,
    &apos;bar&apos;
  ])
}
</code></pre><h4 id="createNamespacedHelpers命名空间辅助函数。它返回一个对象"><a href="#createNamespacedHelpers命名空间辅助函数。它返回一个对象" class="headerlink" title="createNamespacedHelpers命名空间辅助函数。它返回一个对象"></a>createNamespacedHelpers命名空间辅助函数。它返回一个对象</h4><pre><code>import { createNamespacedHelpers } from &apos;vuex&apos;

***const { mapState, mapActions } = createNamespacedHelpers(&apos;some/nested/module&apos;)

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state =&gt; state.a,
      b: state =&gt; state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      &apos;foo&apos;,
      &apos;bar&apos;
    ])
  }
}
</code></pre><h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><pre><code>store.registerModule(&apos;myMoudule&apos;,{
    ...
})//注册模块`myModule`
store.registerModule([&apos;nested&apos;,&apos;myMoudel&apos;]),{
    ...
}//注册嵌套模`nested/myModule`
</code></pre><p>通过store.state.myMoudel和store.state.nested.myMoudel访问</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://Shelly-Shen.github.io/2018/10/16/vuex/" data-id="cjnbfi9yx0001zchoelfjdwoq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/16/vue-cil/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          vue-cil
        
      </div>
    </a>
  
  
    <a href="/2018/10/16/async-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">async</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/16/vue-cil/">vue-cil</a>
          </li>
        
          <li>
            <a href="/2018/10/16/vuex/">vuex</a>
          </li>
        
          <li>
            <a href="/2018/10/16/async-1/">async</a>
          </li>
        
          <li>
            <a href="/2018/10/16/闭包/">闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>